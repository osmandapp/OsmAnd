// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osmand_odb.proto

#ifndef PROTOBUF_osmand_5fodb_2eproto__INCLUDED
#define PROTOBUF_osmand_5fodb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_osmand_5fodb_2eproto();
void protobuf_AssignDesc_osmand_5fodb_2eproto();
void protobuf_ShutdownFile_osmand_5fodb_2eproto();

class OsmAndStructure;
class StringTable;
class IndexedStringTable;
class OsmAndMapIndex;
class MapEncodingRule;
class MapRootLevel;
class MapTree;
class MapData;
class OsmAndAddressIndex;
class CitiesIndex;
class PostcodesIndex;
class CityIndex;
class InteresectedStreets;
class StreetIntersection;
class PostcodeIndex;
class StreetIndex;
class BuildingIndex;
class TransportRoutes;
class TransportRoute;
class TransportRouteStop;
class TransportStop;
class TransportStopsTree;
class OsmAndTransportIndex;
class OsmAndTileBox;
class OsmAndPoiIndex;
class OsmAndPoiNameIndex;
class OsmAndPoiNameIndexData;
class OsmAndPoiNameIndexDataAtom;
class OsmAndCategoryTable;
class OsmAndPoiBox;
class OsmAndPoiCategories;
class OsmAndPoiBoxData;
class OsmAndPoiBoxDataAtom;

// ===================================================================

class OsmAndStructure : public ::google::protobuf::Message {
 public:
  OsmAndStructure();
  virtual ~OsmAndStructure();
  
  OsmAndStructure(const OsmAndStructure& from);
  
  inline OsmAndStructure& operator=(const OsmAndStructure& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndStructure& default_instance();
  
  void Swap(OsmAndStructure* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndStructure& from);
  void MergeFrom(const OsmAndStructure& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // repeated .OsmAndMapIndex mapIndex = 2;
  inline int mapindex_size() const;
  inline void clear_mapindex();
  static const int kMapIndexFieldNumber = 2;
  inline const ::OsmAndMapIndex& mapindex(int index) const;
  inline ::OsmAndMapIndex* mutable_mapindex(int index);
  inline ::OsmAndMapIndex* add_mapindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex >&
      mapindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex >*
      mutable_mapindex();
  
  // repeated .OsmAndAddressIndex addressIndex = 3;
  inline int addressindex_size() const;
  inline void clear_addressindex();
  static const int kAddressIndexFieldNumber = 3;
  inline const ::OsmAndAddressIndex& addressindex(int index) const;
  inline ::OsmAndAddressIndex* mutable_addressindex(int index);
  inline ::OsmAndAddressIndex* add_addressindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex >&
      addressindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex >*
      mutable_addressindex();
  
  // repeated .OsmAndTransportIndex transportIndex = 4;
  inline int transportindex_size() const;
  inline void clear_transportindex();
  static const int kTransportIndexFieldNumber = 4;
  inline const ::OsmAndTransportIndex& transportindex(int index) const;
  inline ::OsmAndTransportIndex* mutable_transportindex(int index);
  inline ::OsmAndTransportIndex* add_transportindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex >&
      transportindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex >*
      mutable_transportindex();
  
  // repeated .OsmAndPoiIndex poiIndex = 5;
  inline int poiindex_size() const;
  inline void clear_poiindex();
  static const int kPoiIndexFieldNumber = 5;
  inline const ::OsmAndPoiIndex& poiindex(int index) const;
  inline ::OsmAndPoiIndex* mutable_poiindex(int index);
  inline ::OsmAndPoiIndex* add_poiindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex >&
      poiindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex >*
      mutable_poiindex();
  
  // required uint32 versionConfirm = 32;
  inline bool has_versionconfirm() const;
  inline void clear_versionconfirm();
  static const int kVersionConfirmFieldNumber = 32;
  inline ::google::protobuf::uint32 versionconfirm() const;
  inline void set_versionconfirm(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndStructure)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 version_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex > mapindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex > addressindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex > transportindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex > poiindex_;
  ::google::protobuf::uint32 versionconfirm_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndStructure* default_instance_;
};
// -------------------------------------------------------------------

class StringTable : public ::google::protobuf::Message {
 public:
  StringTable();
  virtual ~StringTable();
  
  StringTable(const StringTable& from);
  
  inline StringTable& operator=(const StringTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringTable& default_instance();
  
  void Swap(StringTable* other);
  
  // implements Message ----------------------------------------------
  
  StringTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringTable& from);
  void MergeFrom(const StringTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string s = 1;
  inline int s_size() const;
  inline void clear_s();
  static const int kSFieldNumber = 1;
  inline const ::std::string& s(int index) const;
  inline ::std::string* mutable_s(int index);
  inline void set_s(int index, const ::std::string& value);
  inline void set_s(int index, const char* value);
  inline void set_s(int index, const char* value, size_t size);
  inline ::std::string* add_s();
  inline void add_s(const ::std::string& value);
  inline void add_s(const char* value);
  inline void add_s(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& s() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_s();
  
  // @@protoc_insertion_point(class_scope:StringTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> s_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StringTable* default_instance_;
};
// -------------------------------------------------------------------

class IndexedStringTable : public ::google::protobuf::Message {
 public:
  IndexedStringTable();
  virtual ~IndexedStringTable();
  
  IndexedStringTable(const IndexedStringTable& from);
  
  inline IndexedStringTable& operator=(const IndexedStringTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexedStringTable& default_instance();
  
  void Swap(IndexedStringTable* other);
  
  // implements Message ----------------------------------------------
  
  IndexedStringTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexedStringTable& from);
  void MergeFrom(const IndexedStringTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  
  // repeated string key = 3;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key(int index) const;
  inline ::std::string* mutable_key(int index);
  inline void set_key(int index, const ::std::string& value);
  inline void set_key(int index, const char* value);
  inline void set_key(int index, const char* value, size_t size);
  inline ::std::string* add_key();
  inline void add_key(const ::std::string& value);
  inline void add_key(const char* value);
  inline void add_key(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key();
  
  // repeated uint32 val = 4;
  inline int val_size() const;
  inline void clear_val();
  static const int kValFieldNumber = 4;
  inline ::google::protobuf::uint32 val(int index) const;
  inline void set_val(int index, ::google::protobuf::uint32 value);
  inline void add_val(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      val() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_val();
  
  // repeated .IndexedStringTable subtables = 5;
  inline int subtables_size() const;
  inline void clear_subtables();
  static const int kSubtablesFieldNumber = 5;
  inline const ::IndexedStringTable& subtables(int index) const;
  inline ::IndexedStringTable* mutable_subtables(int index);
  inline ::IndexedStringTable* add_subtables();
  inline const ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >&
      subtables() const;
  inline ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >*
      mutable_subtables();
  
  // @@protoc_insertion_point(class_scope:IndexedStringTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* prefix_;
  static const ::std::string _default_prefix_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > val_;
  ::google::protobuf::RepeatedPtrField< ::IndexedStringTable > subtables_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IndexedStringTable* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex();
  virtual ~OsmAndMapIndex();
  
  OsmAndMapIndex(const OsmAndMapIndex& from);
  
  inline OsmAndMapIndex& operator=(const OsmAndMapIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex& default_instance();
  
  void Swap(OsmAndMapIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndMapIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex& from);
  void MergeFrom(const OsmAndMapIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .MapRootLevel levels = 1;
  inline int levels_size() const;
  inline void clear_levels();
  static const int kLevelsFieldNumber = 1;
  inline const ::MapRootLevel& levels(int index) const;
  inline ::MapRootLevel* mutable_levels(int index);
  inline ::MapRootLevel* add_levels();
  inline const ::google::protobuf::RepeatedPtrField< ::MapRootLevel >&
      levels() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapRootLevel >*
      mutable_levels();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated .MapEncodingRule rules = 8;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 8;
  inline const ::MapEncodingRule& rules(int index) const;
  inline ::MapEncodingRule* mutable_rules(int index);
  inline ::MapEncodingRule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::MapEncodingRule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapEncodingRule >*
      mutable_rules();
  
  // @@protoc_insertion_point(class_scope:OsmAndMapIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::MapRootLevel > levels_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::MapEncodingRule > rules_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndMapIndex* default_instance_;
};
// -------------------------------------------------------------------

class MapEncodingRule : public ::google::protobuf::Message {
 public:
  MapEncodingRule();
  virtual ~MapEncodingRule();
  
  MapEncodingRule(const MapEncodingRule& from);
  
  inline MapEncodingRule& operator=(const MapEncodingRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEncodingRule& default_instance();
  
  void Swap(MapEncodingRule* other);
  
  // implements Message ----------------------------------------------
  
  MapEncodingRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapEncodingRule& from);
  void MergeFrom(const MapEncodingRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // optional string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // required uint32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // required uint32 subtype = 7;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubtypeFieldNumber = 7;
  inline ::google::protobuf::uint32 subtype() const;
  inline void set_subtype(::google::protobuf::uint32 value);
  
  // optional uint32 minZoom = 9;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinZoomFieldNumber = 9;
  inline ::google::protobuf::uint32 minzoom() const;
  inline void set_minzoom(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MapEncodingRule)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 subtype_;
  ::google::protobuf::uint32 minzoom_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MapEncodingRule* default_instance_;
};
// -------------------------------------------------------------------

class MapRootLevel : public ::google::protobuf::Message {
 public:
  MapRootLevel();
  virtual ~MapRootLevel();
  
  MapRootLevel(const MapRootLevel& from);
  
  inline MapRootLevel& operator=(const MapRootLevel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapRootLevel& default_instance();
  
  void Swap(MapRootLevel* other);
  
  // implements Message ----------------------------------------------
  
  MapRootLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapRootLevel& from);
  void MergeFrom(const MapRootLevel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 maxZoom = 1;
  inline bool has_maxzoom() const;
  inline void clear_maxzoom();
  static const int kMaxZoomFieldNumber = 1;
  inline ::google::protobuf::int32 maxzoom() const;
  inline void set_maxzoom(::google::protobuf::int32 value);
  
  // required int32 minZoom = 2;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinZoomFieldNumber = 2;
  inline ::google::protobuf::int32 minzoom() const;
  inline void set_minzoom(::google::protobuf::int32 value);
  
  // required int32 left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required int32 right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required int32 top = 5;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 5;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required int32 bottom = 6;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 6;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // repeated .MapTree root = 7;
  inline int root_size() const;
  inline void clear_root();
  static const int kRootFieldNumber = 7;
  inline const ::MapTree& root(int index) const;
  inline ::MapTree* mutable_root(int index);
  inline ::MapTree* add_root();
  inline const ::google::protobuf::RepeatedPtrField< ::MapTree >&
      root() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapTree >*
      mutable_root();
  
  // @@protoc_insertion_point(class_scope:MapRootLevel)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 maxzoom_;
  ::google::protobuf::int32 minzoom_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::MapTree > root_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MapRootLevel* default_instance_;
};
// -------------------------------------------------------------------

class MapTree : public ::google::protobuf::Message {
 public:
  MapTree();
  virtual ~MapTree();
  
  MapTree(const MapTree& from);
  
  inline MapTree& operator=(const MapTree& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapTree& default_instance();
  
  void Swap(MapTree* other);
  
  // implements Message ----------------------------------------------
  
  MapTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapTree& from);
  void MergeFrom(const MapTree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // optional .StringTable oldstringTable = 5;
  inline bool has_oldstringtable() const;
  inline void clear_oldstringtable();
  static const int kOldstringTableFieldNumber = 5;
  inline const ::StringTable& oldstringtable() const;
  inline ::StringTable* mutable_oldstringtable();
  
  // optional uint64 oldbaseId = 6;
  inline bool has_oldbaseid() const;
  inline void clear_oldbaseid();
  static const int kOldbaseIdFieldNumber = 6;
  inline ::google::protobuf::uint64 oldbaseid() const;
  inline void set_oldbaseid(::google::protobuf::uint64 value);
  
  // repeated .MapTree subtrees = 7;
  inline int subtrees_size() const;
  inline void clear_subtrees();
  static const int kSubtreesFieldNumber = 7;
  inline const ::MapTree& subtrees(int index) const;
  inline ::MapTree* mutable_subtrees(int index);
  inline ::MapTree* add_subtrees();
  inline const ::google::protobuf::RepeatedPtrField< ::MapTree >&
      subtrees() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapTree >*
      mutable_subtrees();
  
  // repeated .MapData leafs = 8;
  inline int leafs_size() const;
  inline void clear_leafs();
  static const int kLeafsFieldNumber = 8;
  inline const ::MapData& leafs(int index) const;
  inline ::MapData* mutable_leafs(int index);
  inline ::MapData* add_leafs();
  inline const ::google::protobuf::RepeatedPtrField< ::MapData >&
      leafs() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapData >*
      mutable_leafs();
  
  // optional uint64 baseId = 10;
  inline bool has_baseid() const;
  inline void clear_baseid();
  static const int kBaseIdFieldNumber = 10;
  inline ::google::protobuf::uint64 baseid() const;
  inline void set_baseid(::google::protobuf::uint64 value);
  
  // optional .StringTable stringTable = 11;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 11;
  inline const ::StringTable& stringtable() const;
  inline ::StringTable* mutable_stringtable();
  
  // @@protoc_insertion_point(class_scope:MapTree)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::StringTable* oldstringtable_;
  ::google::protobuf::uint64 oldbaseid_;
  ::google::protobuf::RepeatedPtrField< ::MapTree > subtrees_;
  ::google::protobuf::RepeatedPtrField< ::MapData > leafs_;
  ::google::protobuf::uint64 baseid_;
  ::StringTable* stringtable_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MapTree* default_instance_;
};
// -------------------------------------------------------------------

class MapData : public ::google::protobuf::Message {
 public:
  MapData();
  virtual ~MapData();
  
  MapData(const MapData& from);
  
  inline MapData& operator=(const MapData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapData& default_instance();
  
  void Swap(MapData* other);
  
  // implements Message ----------------------------------------------
  
  MapData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapData& from);
  void MergeFrom(const MapData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes coordinates = 1;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 1;
  inline const ::std::string& coordinates() const;
  inline void set_coordinates(const ::std::string& value);
  inline void set_coordinates(const char* value);
  inline void set_coordinates(const void* value, size_t size);
  inline ::std::string* mutable_coordinates();
  
  // required bytes types = 2;
  inline bool has_types() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 2;
  inline const ::std::string& types() const;
  inline void set_types(const ::std::string& value);
  inline void set_types(const char* value);
  inline void set_types(const void* value, size_t size);
  inline ::std::string* mutable_types();
  
  // required sint64 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // optional uint32 stringId = 4;
  inline bool has_stringid() const;
  inline void clear_stringid();
  static const int kStringIdFieldNumber = 4;
  inline ::google::protobuf::uint32 stringid() const;
  inline void set_stringid(::google::protobuf::uint32 value);
  
  // optional bytes restrictions = 5;
  inline bool has_restrictions() const;
  inline void clear_restrictions();
  static const int kRestrictionsFieldNumber = 5;
  inline const ::std::string& restrictions() const;
  inline void set_restrictions(const ::std::string& value);
  inline void set_restrictions(const char* value);
  inline void set_restrictions(const void* value, size_t size);
  inline ::std::string* mutable_restrictions();
  
  // optional int32 highwayMeta = 6;
  inline bool has_highwaymeta() const;
  inline void clear_highwaymeta();
  static const int kHighwayMetaFieldNumber = 6;
  inline ::google::protobuf::int32 highwaymeta() const;
  inline void set_highwaymeta(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:MapData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* coordinates_;
  static const ::std::string _default_coordinates_;
  ::std::string* types_;
  static const ::std::string _default_types_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::uint32 stringid_;
  ::std::string* restrictions_;
  static const ::std::string _default_restrictions_;
  ::google::protobuf::int32 highwaymeta_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MapData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressIndex : public ::google::protobuf::Message {
 public:
  OsmAndAddressIndex();
  virtual ~OsmAndAddressIndex();
  
  OsmAndAddressIndex(const OsmAndAddressIndex& from);
  
  inline OsmAndAddressIndex& operator=(const OsmAndAddressIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressIndex& default_instance();
  
  void Swap(OsmAndAddressIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndAddressIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressIndex& from);
  void MergeFrom(const OsmAndAddressIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional .CitiesIndex cities = 5;
  inline bool has_cities() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 5;
  inline const ::CitiesIndex& cities() const;
  inline ::CitiesIndex* mutable_cities();
  
  // optional .PostcodesIndex postcodes = 6;
  inline bool has_postcodes() const;
  inline void clear_postcodes();
  static const int kPostcodesFieldNumber = 6;
  inline const ::PostcodesIndex& postcodes() const;
  inline ::PostcodesIndex* mutable_postcodes();
  
  // optional .CitiesIndex villages = 7;
  inline bool has_villages() const;
  inline void clear_villages();
  static const int kVillagesFieldNumber = 7;
  inline const ::CitiesIndex& villages() const;
  inline ::CitiesIndex* mutable_villages();
  
  // @@protoc_insertion_point(class_scope:OsmAndAddressIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::CitiesIndex* cities_;
  ::PostcodesIndex* postcodes_;
  ::CitiesIndex* villages_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndAddressIndex* default_instance_;
};
// -------------------------------------------------------------------

class CitiesIndex : public ::google::protobuf::Message {
 public:
  CitiesIndex();
  virtual ~CitiesIndex();
  
  CitiesIndex(const CitiesIndex& from);
  
  inline CitiesIndex& operator=(const CitiesIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CitiesIndex& default_instance();
  
  void Swap(CitiesIndex* other);
  
  // implements Message ----------------------------------------------
  
  CitiesIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CitiesIndex& from);
  void MergeFrom(const CitiesIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .CityIndex cities = 1;
  inline int cities_size() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 1;
  inline const ::CityIndex& cities(int index) const;
  inline ::CityIndex* mutable_cities(int index);
  inline ::CityIndex* add_cities();
  inline const ::google::protobuf::RepeatedPtrField< ::CityIndex >&
      cities() const;
  inline ::google::protobuf::RepeatedPtrField< ::CityIndex >*
      mutable_cities();
  
  // @@protoc_insertion_point(class_scope:CitiesIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::CityIndex > cities_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CitiesIndex* default_instance_;
};
// -------------------------------------------------------------------

class PostcodesIndex : public ::google::protobuf::Message {
 public:
  PostcodesIndex();
  virtual ~PostcodesIndex();
  
  PostcodesIndex(const PostcodesIndex& from);
  
  inline PostcodesIndex& operator=(const PostcodesIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PostcodesIndex& default_instance();
  
  void Swap(PostcodesIndex* other);
  
  // implements Message ----------------------------------------------
  
  PostcodesIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostcodesIndex& from);
  void MergeFrom(const PostcodesIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PostcodeIndex postcodes = 1;
  inline int postcodes_size() const;
  inline void clear_postcodes();
  static const int kPostcodesFieldNumber = 1;
  inline const ::PostcodeIndex& postcodes(int index) const;
  inline ::PostcodeIndex* mutable_postcodes(int index);
  inline ::PostcodeIndex* add_postcodes();
  inline const ::google::protobuf::RepeatedPtrField< ::PostcodeIndex >&
      postcodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::PostcodeIndex >*
      mutable_postcodes();
  
  // @@protoc_insertion_point(class_scope:PostcodesIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::PostcodeIndex > postcodes_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PostcodesIndex* default_instance_;
};
// -------------------------------------------------------------------

class CityIndex : public ::google::protobuf::Message {
 public:
  CityIndex();
  virtual ~CityIndex();
  
  CityIndex(const CityIndex& from);
  
  inline CityIndex& operator=(const CityIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CityIndex& default_instance();
  
  void Swap(CityIndex* other);
  
  // implements Message ----------------------------------------------
  
  CityIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CityIndex& from);
  void MergeFrom(const CityIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 city_type = 1;
  inline bool has_city_type() const;
  inline void clear_city_type();
  static const int kCityTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 city_type() const;
  inline void set_city_type(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 3;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 3;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional uint64 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // required fixed32 x = 5;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 5;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // required fixed32 y = 6;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 6;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // optional .InteresectedStreets intersections = 14;
  inline bool has_intersections() const;
  inline void clear_intersections();
  static const int kIntersectionsFieldNumber = 14;
  inline const ::InteresectedStreets& intersections() const;
  inline ::InteresectedStreets* mutable_intersections();
  
  // repeated .StreetIndex streets = 18;
  inline int streets_size() const;
  inline void clear_streets();
  static const int kStreetsFieldNumber = 18;
  inline const ::StreetIndex& streets(int index) const;
  inline ::StreetIndex* mutable_streets(int index);
  inline ::StreetIndex* add_streets();
  inline const ::google::protobuf::RepeatedPtrField< ::StreetIndex >&
      streets() const;
  inline ::google::protobuf::RepeatedPtrField< ::StreetIndex >*
      mutable_streets();
  
  // @@protoc_insertion_point(class_scope:CityIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 city_type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::InteresectedStreets* intersections_;
  ::google::protobuf::RepeatedPtrField< ::StreetIndex > streets_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CityIndex* default_instance_;
};
// -------------------------------------------------------------------

class InteresectedStreets : public ::google::protobuf::Message {
 public:
  InteresectedStreets();
  virtual ~InteresectedStreets();
  
  InteresectedStreets(const InteresectedStreets& from);
  
  inline InteresectedStreets& operator=(const InteresectedStreets& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InteresectedStreets& default_instance();
  
  void Swap(InteresectedStreets* other);
  
  // implements Message ----------------------------------------------
  
  InteresectedStreets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InteresectedStreets& from);
  void MergeFrom(const InteresectedStreets& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .StreetIntersection intersections = 5;
  inline int intersections_size() const;
  inline void clear_intersections();
  static const int kIntersectionsFieldNumber = 5;
  inline const ::StreetIntersection& intersections(int index) const;
  inline ::StreetIntersection* mutable_intersections(int index);
  inline ::StreetIntersection* add_intersections();
  inline const ::google::protobuf::RepeatedPtrField< ::StreetIntersection >&
      intersections() const;
  inline ::google::protobuf::RepeatedPtrField< ::StreetIntersection >*
      mutable_intersections();
  
  // @@protoc_insertion_point(class_scope:InteresectedStreets)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::StreetIntersection > intersections_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static InteresectedStreets* default_instance_;
};
// -------------------------------------------------------------------

class StreetIntersection : public ::google::protobuf::Message {
 public:
  StreetIntersection();
  virtual ~StreetIntersection();
  
  StreetIntersection(const StreetIntersection& from);
  
  inline StreetIntersection& operator=(const StreetIntersection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetIntersection& default_instance();
  
  void Swap(StreetIntersection* other);
  
  // implements Message ----------------------------------------------
  
  StreetIntersection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetIntersection& from);
  void MergeFrom(const StreetIntersection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 intersectedStreet1 = 2;
  inline bool has_intersectedstreet1() const;
  inline void clear_intersectedstreet1();
  static const int kIntersectedStreet1FieldNumber = 2;
  inline ::google::protobuf::uint32 intersectedstreet1() const;
  inline void set_intersectedstreet1(::google::protobuf::uint32 value);
  
  // required uint32 intersectedStreet2 = 3;
  inline bool has_intersectedstreet2() const;
  inline void clear_intersectedstreet2();
  static const int kIntersectedStreet2FieldNumber = 3;
  inline ::google::protobuf::uint32 intersectedstreet2() const;
  inline void set_intersectedstreet2(::google::protobuf::uint32 value);
  
  // required sint32 intersectedX = 4;
  inline bool has_intersectedx() const;
  inline void clear_intersectedx();
  static const int kIntersectedXFieldNumber = 4;
  inline ::google::protobuf::int32 intersectedx() const;
  inline void set_intersectedx(::google::protobuf::int32 value);
  
  // required sint32 intersectedY = 5;
  inline bool has_intersectedy() const;
  inline void clear_intersectedy();
  static const int kIntersectedYFieldNumber = 5;
  inline ::google::protobuf::int32 intersectedy() const;
  inline void set_intersectedy(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:StreetIntersection)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 intersectedstreet1_;
  ::google::protobuf::uint32 intersectedstreet2_;
  ::google::protobuf::int32 intersectedx_;
  ::google::protobuf::int32 intersectedy_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StreetIntersection* default_instance_;
};
// -------------------------------------------------------------------

class PostcodeIndex : public ::google::protobuf::Message {
 public:
  PostcodeIndex();
  virtual ~PostcodeIndex();
  
  PostcodeIndex(const PostcodeIndex& from);
  
  inline PostcodeIndex& operator=(const PostcodeIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PostcodeIndex& default_instance();
  
  void Swap(PostcodeIndex* other);
  
  // implements Message ----------------------------------------------
  
  PostcodeIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostcodeIndex& from);
  void MergeFrom(const PostcodeIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string postcode = 1;
  inline bool has_postcode() const;
  inline void clear_postcode();
  static const int kPostcodeFieldNumber = 1;
  inline const ::std::string& postcode() const;
  inline void set_postcode(const ::std::string& value);
  inline void set_postcode(const char* value);
  inline void set_postcode(const char* value, size_t size);
  inline ::std::string* mutable_postcode();
  
  // required fixed32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // required fixed32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // repeated .StreetIndex streets = 5;
  inline int streets_size() const;
  inline void clear_streets();
  static const int kStreetsFieldNumber = 5;
  inline const ::StreetIndex& streets(int index) const;
  inline ::StreetIndex* mutable_streets(int index);
  inline ::StreetIndex* add_streets();
  inline const ::google::protobuf::RepeatedPtrField< ::StreetIndex >&
      streets() const;
  inline ::google::protobuf::RepeatedPtrField< ::StreetIndex >*
      mutable_streets();
  
  // @@protoc_insertion_point(class_scope:PostcodeIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* postcode_;
  static const ::std::string _default_postcode_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::RepeatedPtrField< ::StreetIndex > streets_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PostcodeIndex* default_instance_;
};
// -------------------------------------------------------------------

class StreetIndex : public ::google::protobuf::Message {
 public:
  StreetIndex();
  virtual ~StreetIndex();
  
  StreetIndex(const StreetIndex& from);
  
  inline StreetIndex& operator=(const StreetIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetIndex& default_instance();
  
  void Swap(StreetIndex* other);
  
  // implements Message ----------------------------------------------
  
  StreetIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetIndex& from);
  void MergeFrom(const StreetIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // required sint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required sint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional uint64 id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // repeated .BuildingIndex buildings = 18;
  inline int buildings_size() const;
  inline void clear_buildings();
  static const int kBuildingsFieldNumber = 18;
  inline const ::BuildingIndex& buildings(int index) const;
  inline ::BuildingIndex* mutable_buildings(int index);
  inline ::BuildingIndex* add_buildings();
  inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
      buildings() const;
  inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
      mutable_buildings();
  
  // @@protoc_insertion_point(class_scope:StreetIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedPtrField< ::BuildingIndex > buildings_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StreetIndex* default_instance_;
};
// -------------------------------------------------------------------

class BuildingIndex : public ::google::protobuf::Message {
 public:
  BuildingIndex();
  virtual ~BuildingIndex();
  
  BuildingIndex(const BuildingIndex& from);
  
  inline BuildingIndex& operator=(const BuildingIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingIndex& default_instance();
  
  void Swap(BuildingIndex* other);
  
  // implements Message ----------------------------------------------
  
  BuildingIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingIndex& from);
  void MergeFrom(const BuildingIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional uint64 id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional string postcode = 6;
  inline bool has_postcode() const;
  inline void clear_postcode();
  static const int kPostcodeFieldNumber = 6;
  inline const ::std::string& postcode() const;
  inline void set_postcode(const ::std::string& value);
  inline void set_postcode(const char* value);
  inline void set_postcode(const char* value, size_t size);
  inline ::std::string* mutable_postcode();
  
  // required sint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required sint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:BuildingIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::uint64 id_;
  ::std::string* postcode_;
  static const ::std::string _default_postcode_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BuildingIndex* default_instance_;
};
// -------------------------------------------------------------------

class TransportRoutes : public ::google::protobuf::Message {
 public:
  TransportRoutes();
  virtual ~TransportRoutes();
  
  TransportRoutes(const TransportRoutes& from);
  
  inline TransportRoutes& operator=(const TransportRoutes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRoutes& default_instance();
  
  void Swap(TransportRoutes* other);
  
  // implements Message ----------------------------------------------
  
  TransportRoutes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRoutes& from);
  void MergeFrom(const TransportRoutes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .TransportRoute routes = 6;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 6;
  inline const ::TransportRoute& routes(int index) const;
  inline ::TransportRoute* mutable_routes(int index);
  inline ::TransportRoute* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRoute >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRoute >*
      mutable_routes();
  
  // @@protoc_insertion_point(class_scope:TransportRoutes)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::TransportRoute > routes_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRoutes* default_instance_;
};
// -------------------------------------------------------------------

class TransportRoute : public ::google::protobuf::Message {
 public:
  TransportRoute();
  virtual ~TransportRoute();
  
  TransportRoute(const TransportRoute& from);
  
  inline TransportRoute& operator=(const TransportRoute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRoute& default_instance();
  
  void Swap(TransportRoute* other);
  
  // implements Message ----------------------------------------------
  
  TransportRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRoute& from);
  void MergeFrom(const TransportRoute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint32 operator = 4;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 4;
  inline ::google::protobuf::uint32 operator_() const;
  inline void set_operator_(::google::protobuf::uint32 value);
  
  // optional string ref = 5;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 5;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  
  // optional uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // optional uint32 distance = 8;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 8;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);
  
  // repeated .TransportRouteStop directStops = 15;
  inline int directstops_size() const;
  inline void clear_directstops();
  static const int kDirectStopsFieldNumber = 15;
  inline const ::TransportRouteStop& directstops(int index) const;
  inline ::TransportRouteStop* mutable_directstops(int index);
  inline ::TransportRouteStop* add_directstops();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
      directstops() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
      mutable_directstops();
  
  // repeated .TransportRouteStop reverseStops = 16;
  inline int reversestops_size() const;
  inline void clear_reversestops();
  static const int kReverseStopsFieldNumber = 16;
  inline const ::TransportRouteStop& reversestops(int index) const;
  inline ::TransportRouteStop* mutable_reversestops(int index);
  inline ::TransportRouteStop* add_reversestops();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
      reversestops() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
      mutable_reversestops();
  
  // @@protoc_insertion_point(class_scope:TransportRoute)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 operator__;
  ::std::string* ref_;
  static const ::std::string _default_ref_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  ::google::protobuf::uint32 distance_;
  ::google::protobuf::RepeatedPtrField< ::TransportRouteStop > directstops_;
  ::google::protobuf::RepeatedPtrField< ::TransportRouteStop > reversestops_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRoute* default_instance_;
};
// -------------------------------------------------------------------

class TransportRouteStop : public ::google::protobuf::Message {
 public:
  TransportRouteStop();
  virtual ~TransportRouteStop();
  
  TransportRouteStop(const TransportRouteStop& from);
  
  inline TransportRouteStop& operator=(const TransportRouteStop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRouteStop& default_instance();
  
  void Swap(TransportRouteStop* other);
  
  // implements Message ----------------------------------------------
  
  TransportRouteStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRouteStop& from);
  void MergeFrom(const TransportRouteStop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // required uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:TransportRouteStop)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRouteStop* default_instance_;
};
// -------------------------------------------------------------------

class TransportStop : public ::google::protobuf::Message {
 public:
  TransportStop();
  virtual ~TransportStop();
  
  TransportStop(const TransportStop& from);
  
  inline TransportStop& operator=(const TransportStop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStop& default_instance();
  
  void Swap(TransportStop* other);
  
  // implements Message ----------------------------------------------
  
  TransportStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStop& from);
  void MergeFrom(const TransportStop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 dx = 1;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 1;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 2;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 2;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // required sint64 id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // required uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // repeated uint32 routes = 16;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 16;
  inline ::google::protobuf::uint32 routes(int index) const;
  inline void set_routes(int index, ::google::protobuf::uint32 value);
  inline void add_routes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      routes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_routes();
  
  // @@protoc_insertion_point(class_scope:TransportStop)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > routes_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportStop* default_instance_;
};
// -------------------------------------------------------------------

class TransportStopsTree : public ::google::protobuf::Message {
 public:
  TransportStopsTree();
  virtual ~TransportStopsTree();
  
  TransportStopsTree(const TransportStopsTree& from);
  
  inline TransportStopsTree& operator=(const TransportStopsTree& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStopsTree& default_instance();
  
  void Swap(TransportStopsTree* other);
  
  // implements Message ----------------------------------------------
  
  TransportStopsTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStopsTree& from);
  void MergeFrom(const TransportStopsTree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // repeated .TransportStopsTree subtrees = 7;
  inline int subtrees_size() const;
  inline void clear_subtrees();
  static const int kSubtreesFieldNumber = 7;
  inline const ::TransportStopsTree& subtrees(int index) const;
  inline ::TransportStopsTree* mutable_subtrees(int index);
  inline ::TransportStopsTree* add_subtrees();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >&
      subtrees() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >*
      mutable_subtrees();
  
  // repeated .TransportStop leafs = 8;
  inline int leafs_size() const;
  inline void clear_leafs();
  static const int kLeafsFieldNumber = 8;
  inline const ::TransportStop& leafs(int index) const;
  inline ::TransportStop* mutable_leafs(int index);
  inline ::TransportStop* add_leafs();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportStop >&
      leafs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportStop >*
      mutable_leafs();
  
  // optional uint64 baseId = 16;
  inline bool has_baseid() const;
  inline void clear_baseid();
  static const int kBaseIdFieldNumber = 16;
  inline ::google::protobuf::uint64 baseid() const;
  inline void set_baseid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:TransportStopsTree)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::TransportStopsTree > subtrees_;
  ::google::protobuf::RepeatedPtrField< ::TransportStop > leafs_;
  ::google::protobuf::uint64 baseid_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportStopsTree* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndTransportIndex : public ::google::protobuf::Message {
 public:
  OsmAndTransportIndex();
  virtual ~OsmAndTransportIndex();
  
  OsmAndTransportIndex(const OsmAndTransportIndex& from);
  
  inline OsmAndTransportIndex& operator=(const OsmAndTransportIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndTransportIndex& default_instance();
  
  void Swap(OsmAndTransportIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndTransportIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndTransportIndex& from);
  void MergeFrom(const OsmAndTransportIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional .TransportRoutes routes = 3;
  inline bool has_routes() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 3;
  inline const ::TransportRoutes& routes() const;
  inline ::TransportRoutes* mutable_routes();
  
  // optional .TransportStopsTree stops = 6;
  inline bool has_stops() const;
  inline void clear_stops();
  static const int kStopsFieldNumber = 6;
  inline const ::TransportStopsTree& stops() const;
  inline ::TransportStopsTree* mutable_stops();
  
  // required .StringTable stringTable = 9;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 9;
  inline const ::StringTable& stringtable() const;
  inline ::StringTable* mutable_stringtable();
  
  // @@protoc_insertion_point(class_scope:OsmAndTransportIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::TransportRoutes* routes_;
  ::TransportStopsTree* stops_;
  ::StringTable* stringtable_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndTransportIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndTileBox : public ::google::protobuf::Message {
 public:
  OsmAndTileBox();
  virtual ~OsmAndTileBox();
  
  OsmAndTileBox(const OsmAndTileBox& from);
  
  inline OsmAndTileBox& operator=(const OsmAndTileBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndTileBox& default_instance();
  
  void Swap(OsmAndTileBox* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndTileBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndTileBox& from);
  void MergeFrom(const OsmAndTileBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::uint32 left() const;
  inline void set_left(::google::protobuf::uint32 value);
  
  // required uint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::uint32 right() const;
  inline void set_right(::google::protobuf::uint32 value);
  
  // required uint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::uint32 top() const;
  inline void set_top(::google::protobuf::uint32 value);
  
  // required uint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::uint32 bottom() const;
  inline void set_bottom(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndTileBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 left_;
  ::google::protobuf::uint32 right_;
  ::google::protobuf::uint32 top_;
  ::google::protobuf::uint32 bottom_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndTileBox* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiIndex : public ::google::protobuf::Message {
 public:
  OsmAndPoiIndex();
  virtual ~OsmAndPoiIndex();
  
  OsmAndPoiIndex(const OsmAndPoiIndex& from);
  
  inline OsmAndPoiIndex& operator=(const OsmAndPoiIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiIndex& default_instance();
  
  void Swap(OsmAndPoiIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiIndex& from);
  void MergeFrom(const OsmAndPoiIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .OsmAndTileBox boundaries = 2;
  inline bool has_boundaries() const;
  inline void clear_boundaries();
  static const int kBoundariesFieldNumber = 2;
  inline const ::OsmAndTileBox& boundaries() const;
  inline ::OsmAndTileBox* mutable_boundaries();
  
  // repeated .OsmAndCategoryTable categoriesTable = 3;
  inline int categoriestable_size() const;
  inline void clear_categoriestable();
  static const int kCategoriesTableFieldNumber = 3;
  inline const ::OsmAndCategoryTable& categoriestable(int index) const;
  inline ::OsmAndCategoryTable* mutable_categoriestable(int index);
  inline ::OsmAndCategoryTable* add_categoriestable();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable >&
      categoriestable() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable >*
      mutable_categoriestable();
  
  // optional .OsmAndPoiNameIndex nameIndex = 4;
  inline bool has_nameindex() const;
  inline void clear_nameindex();
  static const int kNameIndexFieldNumber = 4;
  inline const ::OsmAndPoiNameIndex& nameindex() const;
  inline ::OsmAndPoiNameIndex* mutable_nameindex();
  
  // repeated .OsmAndPoiBox boxes = 6;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 6;
  inline const ::OsmAndPoiBox& boxes(int index) const;
  inline ::OsmAndPoiBox* mutable_boxes(int index);
  inline ::OsmAndPoiBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >*
      mutable_boxes();
  
  // repeated .OsmAndPoiBoxData poiData = 9;
  inline int poidata_size() const;
  inline void clear_poidata();
  static const int kPoiDataFieldNumber = 9;
  inline const ::OsmAndPoiBoxData& poidata(int index) const;
  inline ::OsmAndPoiBoxData* mutable_poidata(int index);
  inline ::OsmAndPoiBoxData* add_poidata();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData >&
      poidata() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData >*
      mutable_poidata();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::OsmAndTileBox* boundaries_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable > categoriestable_;
  ::OsmAndPoiNameIndex* nameindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData > poidata_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndex : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndex();
  virtual ~OsmAndPoiNameIndex();
  
  OsmAndPoiNameIndex(const OsmAndPoiNameIndex& from);
  
  inline OsmAndPoiNameIndex& operator=(const OsmAndPoiNameIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndex& default_instance();
  
  void Swap(OsmAndPoiNameIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiNameIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndex& from);
  void MergeFrom(const OsmAndPoiNameIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IndexedStringTable table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline const ::IndexedStringTable& table() const;
  inline ::IndexedStringTable* mutable_table();
  
  // repeated .OsmAndPoiNameIndexData data = 5;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::OsmAndPoiNameIndexData& data(int index) const;
  inline ::OsmAndPoiNameIndexData* mutable_data(int index);
  inline ::OsmAndPoiNameIndexData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexData >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiNameIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::IndexedStringTable* table_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexData > data_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiNameIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndexData : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndexData();
  virtual ~OsmAndPoiNameIndexData();
  
  OsmAndPoiNameIndexData(const OsmAndPoiNameIndexData& from);
  
  inline OsmAndPoiNameIndexData& operator=(const OsmAndPoiNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndexData& default_instance();
  
  void Swap(OsmAndPoiNameIndexData* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndexData& from);
  void MergeFrom(const OsmAndPoiNameIndexData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .OsmAndPoiNameIndexDataAtom atoms = 4;
  inline int atoms_size() const;
  inline void clear_atoms();
  static const int kAtomsFieldNumber = 4;
  inline const ::OsmAndPoiNameIndexDataAtom& atoms(int index) const;
  inline ::OsmAndPoiNameIndexDataAtom* mutable_atoms(int index);
  inline ::OsmAndPoiNameIndexDataAtom* add_atoms();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom >&
      atoms() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom >*
      mutable_atoms();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiNameIndexData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom > atoms_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndexDataAtom : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndexDataAtom();
  virtual ~OsmAndPoiNameIndexDataAtom();
  
  OsmAndPoiNameIndexDataAtom(const OsmAndPoiNameIndexDataAtom& from);
  
  inline OsmAndPoiNameIndexDataAtom& operator=(const OsmAndPoiNameIndexDataAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndexDataAtom& default_instance();
  
  void Swap(OsmAndPoiNameIndexDataAtom* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiNameIndexDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndexDataAtom& from);
  void MergeFrom(const OsmAndPoiNameIndexDataAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 zoom = 2;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 2;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // optional uint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // optional uint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // optional fixed32 shiftTo = 14;
  inline bool has_shiftto() const;
  inline void clear_shiftto();
  static const int kShiftToFieldNumber = 14;
  inline ::google::protobuf::uint32 shiftto() const;
  inline void set_shiftto(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiNameIndexDataAtom)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 shiftto_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiNameIndexDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndCategoryTable : public ::google::protobuf::Message {
 public:
  OsmAndCategoryTable();
  virtual ~OsmAndCategoryTable();
  
  OsmAndCategoryTable(const OsmAndCategoryTable& from);
  
  inline OsmAndCategoryTable& operator=(const OsmAndCategoryTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndCategoryTable& default_instance();
  
  void Swap(OsmAndCategoryTable* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndCategoryTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndCategoryTable& from);
  void MergeFrom(const OsmAndCategoryTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string category = 1;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  
  // repeated string subcategories = 3;
  inline int subcategories_size() const;
  inline void clear_subcategories();
  static const int kSubcategoriesFieldNumber = 3;
  inline const ::std::string& subcategories(int index) const;
  inline ::std::string* mutable_subcategories(int index);
  inline void set_subcategories(int index, const ::std::string& value);
  inline void set_subcategories(int index, const char* value);
  inline void set_subcategories(int index, const char* value, size_t size);
  inline ::std::string* add_subcategories();
  inline void add_subcategories(const ::std::string& value);
  inline void add_subcategories(const char* value);
  inline void add_subcategories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& subcategories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subcategories();
  
  // @@protoc_insertion_point(class_scope:OsmAndCategoryTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* category_;
  static const ::std::string _default_category_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subcategories_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndCategoryTable* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBox : public ::google::protobuf::Message {
 public:
  OsmAndPoiBox();
  virtual ~OsmAndPoiBox();
  
  OsmAndPoiBox(const OsmAndPoiBox& from);
  
  inline OsmAndPoiBox& operator=(const OsmAndPoiBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBox& default_instance();
  
  void Swap(OsmAndPoiBox* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBox& from);
  void MergeFrom(const OsmAndPoiBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 zoom = 1;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 1;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // required sint32 left = 2;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 2;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // optional .OsmAndPoiCategories categories = 4;
  inline bool has_categories() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline const ::OsmAndPoiCategories& categories() const;
  inline ::OsmAndPoiCategories* mutable_categories();
  
  // repeated .OsmAndPoiBox subBoxes = 10;
  inline int subboxes_size() const;
  inline void clear_subboxes();
  static const int kSubBoxesFieldNumber = 10;
  inline const ::OsmAndPoiBox& subboxes(int index) const;
  inline ::OsmAndPoiBox* mutable_subboxes(int index);
  inline ::OsmAndPoiBox* add_subboxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >&
      subboxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >*
      mutable_subboxes();
  
  // optional fixed32 shiftToData = 14;
  inline bool has_shifttodata() const;
  inline void clear_shifttodata();
  static const int kShiftToDataFieldNumber = 14;
  inline ::google::protobuf::uint32 shifttodata() const;
  inline void set_shifttodata(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 top_;
  ::OsmAndPoiCategories* categories_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox > subboxes_;
  ::google::protobuf::uint32 shifttodata_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiBox* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiCategories : public ::google::protobuf::Message {
 public:
  OsmAndPoiCategories();
  virtual ~OsmAndPoiCategories();
  
  OsmAndPoiCategories(const OsmAndPoiCategories& from);
  
  inline OsmAndPoiCategories& operator=(const OsmAndPoiCategories& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiCategories& default_instance();
  
  void Swap(OsmAndPoiCategories* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiCategories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiCategories& from);
  void MergeFrom(const OsmAndPoiCategories& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 categories = 3;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 3;
  inline ::google::protobuf::uint32 categories(int index) const;
  inline void set_categories(int index, ::google::protobuf::uint32 value);
  inline void add_categories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      categories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_categories();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiCategories)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > categories_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiCategories* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBoxData : public ::google::protobuf::Message {
 public:
  OsmAndPoiBoxData();
  virtual ~OsmAndPoiBoxData();
  
  OsmAndPoiBoxData(const OsmAndPoiBoxData& from);
  
  inline OsmAndPoiBoxData& operator=(const OsmAndPoiBoxData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBoxData& default_instance();
  
  void Swap(OsmAndPoiBoxData* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiBoxData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBoxData& from);
  void MergeFrom(const OsmAndPoiBoxData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 zoom = 1;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 1;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // optional uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // optional uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // repeated .OsmAndPoiBoxDataAtom poiData = 5;
  inline int poidata_size() const;
  inline void clear_poidata();
  static const int kPoiDataFieldNumber = 5;
  inline const ::OsmAndPoiBoxDataAtom& poidata(int index) const;
  inline ::OsmAndPoiBoxDataAtom* mutable_poidata(int index);
  inline ::OsmAndPoiBoxDataAtom* add_poidata();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom >&
      poidata() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom >*
      mutable_poidata();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiBoxData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom > poidata_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiBoxData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBoxDataAtom : public ::google::protobuf::Message {
 public:
  OsmAndPoiBoxDataAtom();
  virtual ~OsmAndPoiBoxDataAtom();
  
  OsmAndPoiBoxDataAtom(const OsmAndPoiBoxDataAtom& from);
  
  inline OsmAndPoiBoxDataAtom& operator=(const OsmAndPoiBoxDataAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBoxDataAtom& default_instance();
  
  void Swap(OsmAndPoiBoxDataAtom* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiBoxDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBoxDataAtom& from);
  void MergeFrom(const OsmAndPoiBoxDataAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // repeated uint32 categories = 4;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline ::google::protobuf::uint32 categories(int index) const;
  inline void set_categories(int index, ::google::protobuf::uint32 value);
  inline void add_categories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      categories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_categories();
  
  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string nameEn = 7;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameEnFieldNumber = 7;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  
  // optional uint64 id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional string openingHours = 10;
  inline bool has_openinghours() const;
  inline void clear_openinghours();
  static const int kOpeningHoursFieldNumber = 10;
  inline const ::std::string& openinghours() const;
  inline void set_openinghours(const ::std::string& value);
  inline void set_openinghours(const char* value);
  inline void set_openinghours(const char* value, size_t size);
  inline ::std::string* mutable_openinghours();
  
  // optional string site = 11;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 11;
  inline const ::std::string& site() const;
  inline void set_site(const ::std::string& value);
  inline void set_site(const char* value);
  inline void set_site(const char* value, size_t size);
  inline ::std::string* mutable_site();
  
  // optional string phone = 12;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 12;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  
  // optional string note = 13;
  inline bool has_note() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 13;
  inline const ::std::string& note() const;
  inline void set_note(const ::std::string& value);
  inline void set_note(const char* value);
  inline void set_note(const char* value, size_t size);
  inline ::std::string* mutable_note();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiBoxDataAtom)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > categories_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* nameen_;
  static const ::std::string _default_nameen_;
  ::google::protobuf::uint64 id_;
  ::std::string* openinghours_;
  static const ::std::string _default_openinghours_;
  ::std::string* site_;
  static const ::std::string _default_site_;
  ::std::string* phone_;
  static const ::std::string _default_phone_;
  ::std::string* note_;
  static const ::std::string _default_note_;
  friend void  protobuf_AddDesc_osmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_osmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_osmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiBoxDataAtom* default_instance_;
};
// ===================================================================


// ===================================================================

// OsmAndStructure

// required uint32 version = 1;
inline bool OsmAndStructure::has_version() const {
  return _has_bit(0);
}
inline void OsmAndStructure::clear_version() {
  version_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndStructure::version() const {
  return version_;
}
inline void OsmAndStructure::set_version(::google::protobuf::uint32 value) {
  _set_bit(0);
  version_ = value;
}

// repeated .OsmAndMapIndex mapIndex = 2;
inline int OsmAndStructure::mapindex_size() const {
  return mapindex_.size();
}
inline void OsmAndStructure::clear_mapindex() {
  mapindex_.Clear();
}
inline const ::OsmAndMapIndex& OsmAndStructure::mapindex(int index) const {
  return mapindex_.Get(index);
}
inline ::OsmAndMapIndex* OsmAndStructure::mutable_mapindex(int index) {
  return mapindex_.Mutable(index);
}
inline ::OsmAndMapIndex* OsmAndStructure::add_mapindex() {
  return mapindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex >&
OsmAndStructure::mapindex() const {
  return mapindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex >*
OsmAndStructure::mutable_mapindex() {
  return &mapindex_;
}

// repeated .OsmAndAddressIndex addressIndex = 3;
inline int OsmAndStructure::addressindex_size() const {
  return addressindex_.size();
}
inline void OsmAndStructure::clear_addressindex() {
  addressindex_.Clear();
}
inline const ::OsmAndAddressIndex& OsmAndStructure::addressindex(int index) const {
  return addressindex_.Get(index);
}
inline ::OsmAndAddressIndex* OsmAndStructure::mutable_addressindex(int index) {
  return addressindex_.Mutable(index);
}
inline ::OsmAndAddressIndex* OsmAndStructure::add_addressindex() {
  return addressindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex >&
OsmAndStructure::addressindex() const {
  return addressindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex >*
OsmAndStructure::mutable_addressindex() {
  return &addressindex_;
}

// repeated .OsmAndTransportIndex transportIndex = 4;
inline int OsmAndStructure::transportindex_size() const {
  return transportindex_.size();
}
inline void OsmAndStructure::clear_transportindex() {
  transportindex_.Clear();
}
inline const ::OsmAndTransportIndex& OsmAndStructure::transportindex(int index) const {
  return transportindex_.Get(index);
}
inline ::OsmAndTransportIndex* OsmAndStructure::mutable_transportindex(int index) {
  return transportindex_.Mutable(index);
}
inline ::OsmAndTransportIndex* OsmAndStructure::add_transportindex() {
  return transportindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex >&
OsmAndStructure::transportindex() const {
  return transportindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex >*
OsmAndStructure::mutable_transportindex() {
  return &transportindex_;
}

// repeated .OsmAndPoiIndex poiIndex = 5;
inline int OsmAndStructure::poiindex_size() const {
  return poiindex_.size();
}
inline void OsmAndStructure::clear_poiindex() {
  poiindex_.Clear();
}
inline const ::OsmAndPoiIndex& OsmAndStructure::poiindex(int index) const {
  return poiindex_.Get(index);
}
inline ::OsmAndPoiIndex* OsmAndStructure::mutable_poiindex(int index) {
  return poiindex_.Mutable(index);
}
inline ::OsmAndPoiIndex* OsmAndStructure::add_poiindex() {
  return poiindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex >&
OsmAndStructure::poiindex() const {
  return poiindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex >*
OsmAndStructure::mutable_poiindex() {
  return &poiindex_;
}

// required uint32 versionConfirm = 32;
inline bool OsmAndStructure::has_versionconfirm() const {
  return _has_bit(5);
}
inline void OsmAndStructure::clear_versionconfirm() {
  versionconfirm_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 OsmAndStructure::versionconfirm() const {
  return versionconfirm_;
}
inline void OsmAndStructure::set_versionconfirm(::google::protobuf::uint32 value) {
  _set_bit(5);
  versionconfirm_ = value;
}

// -------------------------------------------------------------------

// StringTable

// repeated string s = 1;
inline int StringTable::s_size() const {
  return s_.size();
}
inline void StringTable::clear_s() {
  s_.Clear();
}
inline const ::std::string& StringTable::s(int index) const {
  return s_.Get(index);
}
inline ::std::string* StringTable::mutable_s(int index) {
  return s_.Mutable(index);
}
inline void StringTable::set_s(int index, const ::std::string& value) {
  s_.Mutable(index)->assign(value);
}
inline void StringTable::set_s(int index, const char* value) {
  s_.Mutable(index)->assign(value);
}
inline void StringTable::set_s(int index, const char* value, size_t size) {
  s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringTable::add_s() {
  return s_.Add();
}
inline void StringTable::add_s(const ::std::string& value) {
  s_.Add()->assign(value);
}
inline void StringTable::add_s(const char* value) {
  s_.Add()->assign(value);
}
inline void StringTable::add_s(const char* value, size_t size) {
  s_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringTable::s() const {
  return s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringTable::mutable_s() {
  return &s_;
}

// -------------------------------------------------------------------

// IndexedStringTable

// optional string prefix = 1;
inline bool IndexedStringTable::has_prefix() const {
  return _has_bit(0);
}
inline void IndexedStringTable::clear_prefix() {
  if (prefix_ != &_default_prefix_) {
    prefix_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IndexedStringTable::prefix() const {
  return *prefix_;
}
inline void IndexedStringTable::set_prefix(const ::std::string& value) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void IndexedStringTable::set_prefix(const char* value) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void IndexedStringTable::set_prefix(const char* value, size_t size) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IndexedStringTable::mutable_prefix() {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}

// repeated string key = 3;
inline int IndexedStringTable::key_size() const {
  return key_.size();
}
inline void IndexedStringTable::clear_key() {
  key_.Clear();
}
inline const ::std::string& IndexedStringTable::key(int index) const {
  return key_.Get(index);
}
inline ::std::string* IndexedStringTable::mutable_key(int index) {
  return key_.Mutable(index);
}
inline void IndexedStringTable::set_key(int index, const ::std::string& value) {
  key_.Mutable(index)->assign(value);
}
inline void IndexedStringTable::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
}
inline void IndexedStringTable::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IndexedStringTable::add_key() {
  return key_.Add();
}
inline void IndexedStringTable::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
}
inline void IndexedStringTable::add_key(const char* value) {
  key_.Add()->assign(value);
}
inline void IndexedStringTable::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexedStringTable::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexedStringTable::mutable_key() {
  return &key_;
}

// repeated uint32 val = 4;
inline int IndexedStringTable::val_size() const {
  return val_.size();
}
inline void IndexedStringTable::clear_val() {
  val_.Clear();
}
inline ::google::protobuf::uint32 IndexedStringTable::val(int index) const {
  return val_.Get(index);
}
inline void IndexedStringTable::set_val(int index, ::google::protobuf::uint32 value) {
  val_.Set(index, value);
}
inline void IndexedStringTable::add_val(::google::protobuf::uint32 value) {
  val_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IndexedStringTable::val() const {
  return val_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IndexedStringTable::mutable_val() {
  return &val_;
}

// repeated .IndexedStringTable subtables = 5;
inline int IndexedStringTable::subtables_size() const {
  return subtables_.size();
}
inline void IndexedStringTable::clear_subtables() {
  subtables_.Clear();
}
inline const ::IndexedStringTable& IndexedStringTable::subtables(int index) const {
  return subtables_.Get(index);
}
inline ::IndexedStringTable* IndexedStringTable::mutable_subtables(int index) {
  return subtables_.Mutable(index);
}
inline ::IndexedStringTable* IndexedStringTable::add_subtables() {
  return subtables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >&
IndexedStringTable::subtables() const {
  return subtables_;
}
inline ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >*
IndexedStringTable::mutable_subtables() {
  return &subtables_;
}

// -------------------------------------------------------------------

// OsmAndMapIndex

// repeated .MapRootLevel levels = 1;
inline int OsmAndMapIndex::levels_size() const {
  return levels_.size();
}
inline void OsmAndMapIndex::clear_levels() {
  levels_.Clear();
}
inline const ::MapRootLevel& OsmAndMapIndex::levels(int index) const {
  return levels_.Get(index);
}
inline ::MapRootLevel* OsmAndMapIndex::mutable_levels(int index) {
  return levels_.Mutable(index);
}
inline ::MapRootLevel* OsmAndMapIndex::add_levels() {
  return levels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapRootLevel >&
OsmAndMapIndex::levels() const {
  return levels_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapRootLevel >*
OsmAndMapIndex::mutable_levels() {
  return &levels_;
}

// optional string name = 3;
inline bool OsmAndMapIndex::has_name() const {
  return _has_bit(1);
}
inline void OsmAndMapIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OsmAndMapIndex::name() const {
  return *name_;
}
inline void OsmAndMapIndex::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndMapIndex::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndMapIndex::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndMapIndex::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated .MapEncodingRule rules = 8;
inline int OsmAndMapIndex::rules_size() const {
  return rules_.size();
}
inline void OsmAndMapIndex::clear_rules() {
  rules_.Clear();
}
inline const ::MapEncodingRule& OsmAndMapIndex::rules(int index) const {
  return rules_.Get(index);
}
inline ::MapEncodingRule* OsmAndMapIndex::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::MapEncodingRule* OsmAndMapIndex::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapEncodingRule >&
OsmAndMapIndex::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapEncodingRule >*
OsmAndMapIndex::mutable_rules() {
  return &rules_;
}

// -------------------------------------------------------------------

// MapEncodingRule

// required string tag = 3;
inline bool MapEncodingRule::has_tag() const {
  return _has_bit(0);
}
inline void MapEncodingRule::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MapEncodingRule::tag() const {
  return *tag_;
}
inline void MapEncodingRule::set_tag(const ::std::string& value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void MapEncodingRule::set_tag(const char* value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void MapEncodingRule::set_tag(const char* value, size_t size) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapEncodingRule::mutable_tag() {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// optional string value = 5;
inline bool MapEncodingRule::has_value() const {
  return _has_bit(1);
}
inline void MapEncodingRule::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MapEncodingRule::value() const {
  return *value_;
}
inline void MapEncodingRule::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void MapEncodingRule::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void MapEncodingRule::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapEncodingRule::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// required uint32 type = 6;
inline bool MapEncodingRule::has_type() const {
  return _has_bit(2);
}
inline void MapEncodingRule::clear_type() {
  type_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 MapEncodingRule::type() const {
  return type_;
}
inline void MapEncodingRule::set_type(::google::protobuf::uint32 value) {
  _set_bit(2);
  type_ = value;
}

// required uint32 subtype = 7;
inline bool MapEncodingRule::has_subtype() const {
  return _has_bit(3);
}
inline void MapEncodingRule::clear_subtype() {
  subtype_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 MapEncodingRule::subtype() const {
  return subtype_;
}
inline void MapEncodingRule::set_subtype(::google::protobuf::uint32 value) {
  _set_bit(3);
  subtype_ = value;
}

// optional uint32 minZoom = 9;
inline bool MapEncodingRule::has_minzoom() const {
  return _has_bit(4);
}
inline void MapEncodingRule::clear_minzoom() {
  minzoom_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 MapEncodingRule::minzoom() const {
  return minzoom_;
}
inline void MapEncodingRule::set_minzoom(::google::protobuf::uint32 value) {
  _set_bit(4);
  minzoom_ = value;
}

// -------------------------------------------------------------------

// MapRootLevel

// required int32 maxZoom = 1;
inline bool MapRootLevel::has_maxzoom() const {
  return _has_bit(0);
}
inline void MapRootLevel::clear_maxzoom() {
  maxzoom_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MapRootLevel::maxzoom() const {
  return maxzoom_;
}
inline void MapRootLevel::set_maxzoom(::google::protobuf::int32 value) {
  _set_bit(0);
  maxzoom_ = value;
}

// required int32 minZoom = 2;
inline bool MapRootLevel::has_minzoom() const {
  return _has_bit(1);
}
inline void MapRootLevel::clear_minzoom() {
  minzoom_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MapRootLevel::minzoom() const {
  return minzoom_;
}
inline void MapRootLevel::set_minzoom(::google::protobuf::int32 value) {
  _set_bit(1);
  minzoom_ = value;
}

// required int32 left = 3;
inline bool MapRootLevel::has_left() const {
  return _has_bit(2);
}
inline void MapRootLevel::clear_left() {
  left_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MapRootLevel::left() const {
  return left_;
}
inline void MapRootLevel::set_left(::google::protobuf::int32 value) {
  _set_bit(2);
  left_ = value;
}

// required int32 right = 4;
inline bool MapRootLevel::has_right() const {
  return _has_bit(3);
}
inline void MapRootLevel::clear_right() {
  right_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MapRootLevel::right() const {
  return right_;
}
inline void MapRootLevel::set_right(::google::protobuf::int32 value) {
  _set_bit(3);
  right_ = value;
}

// required int32 top = 5;
inline bool MapRootLevel::has_top() const {
  return _has_bit(4);
}
inline void MapRootLevel::clear_top() {
  top_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 MapRootLevel::top() const {
  return top_;
}
inline void MapRootLevel::set_top(::google::protobuf::int32 value) {
  _set_bit(4);
  top_ = value;
}

// required int32 bottom = 6;
inline bool MapRootLevel::has_bottom() const {
  return _has_bit(5);
}
inline void MapRootLevel::clear_bottom() {
  bottom_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MapRootLevel::bottom() const {
  return bottom_;
}
inline void MapRootLevel::set_bottom(::google::protobuf::int32 value) {
  _set_bit(5);
  bottom_ = value;
}

// repeated .MapTree root = 7;
inline int MapRootLevel::root_size() const {
  return root_.size();
}
inline void MapRootLevel::clear_root() {
  root_.Clear();
}
inline const ::MapTree& MapRootLevel::root(int index) const {
  return root_.Get(index);
}
inline ::MapTree* MapRootLevel::mutable_root(int index) {
  return root_.Mutable(index);
}
inline ::MapTree* MapRootLevel::add_root() {
  return root_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapTree >&
MapRootLevel::root() const {
  return root_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapTree >*
MapRootLevel::mutable_root() {
  return &root_;
}

// -------------------------------------------------------------------

// MapTree

// required sint32 left = 1;
inline bool MapTree::has_left() const {
  return _has_bit(0);
}
inline void MapTree::clear_left() {
  left_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MapTree::left() const {
  return left_;
}
inline void MapTree::set_left(::google::protobuf::int32 value) {
  _set_bit(0);
  left_ = value;
}

// required sint32 right = 2;
inline bool MapTree::has_right() const {
  return _has_bit(1);
}
inline void MapTree::clear_right() {
  right_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MapTree::right() const {
  return right_;
}
inline void MapTree::set_right(::google::protobuf::int32 value) {
  _set_bit(1);
  right_ = value;
}

// required sint32 top = 3;
inline bool MapTree::has_top() const {
  return _has_bit(2);
}
inline void MapTree::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 MapTree::top() const {
  return top_;
}
inline void MapTree::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// required sint32 bottom = 4;
inline bool MapTree::has_bottom() const {
  return _has_bit(3);
}
inline void MapTree::clear_bottom() {
  bottom_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MapTree::bottom() const {
  return bottom_;
}
inline void MapTree::set_bottom(::google::protobuf::int32 value) {
  _set_bit(3);
  bottom_ = value;
}

// optional .StringTable oldstringTable = 5;
inline bool MapTree::has_oldstringtable() const {
  return _has_bit(4);
}
inline void MapTree::clear_oldstringtable() {
  if (oldstringtable_ != NULL) oldstringtable_->::StringTable::Clear();
  _clear_bit(4);
}
inline const ::StringTable& MapTree::oldstringtable() const {
  return oldstringtable_ != NULL ? *oldstringtable_ : *default_instance_->oldstringtable_;
}
inline ::StringTable* MapTree::mutable_oldstringtable() {
  _set_bit(4);
  if (oldstringtable_ == NULL) oldstringtable_ = new ::StringTable;
  return oldstringtable_;
}

// optional uint64 oldbaseId = 6;
inline bool MapTree::has_oldbaseid() const {
  return _has_bit(5);
}
inline void MapTree::clear_oldbaseid() {
  oldbaseid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 MapTree::oldbaseid() const {
  return oldbaseid_;
}
inline void MapTree::set_oldbaseid(::google::protobuf::uint64 value) {
  _set_bit(5);
  oldbaseid_ = value;
}

// repeated .MapTree subtrees = 7;
inline int MapTree::subtrees_size() const {
  return subtrees_.size();
}
inline void MapTree::clear_subtrees() {
  subtrees_.Clear();
}
inline const ::MapTree& MapTree::subtrees(int index) const {
  return subtrees_.Get(index);
}
inline ::MapTree* MapTree::mutable_subtrees(int index) {
  return subtrees_.Mutable(index);
}
inline ::MapTree* MapTree::add_subtrees() {
  return subtrees_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapTree >&
MapTree::subtrees() const {
  return subtrees_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapTree >*
MapTree::mutable_subtrees() {
  return &subtrees_;
}

// repeated .MapData leafs = 8;
inline int MapTree::leafs_size() const {
  return leafs_.size();
}
inline void MapTree::clear_leafs() {
  leafs_.Clear();
}
inline const ::MapData& MapTree::leafs(int index) const {
  return leafs_.Get(index);
}
inline ::MapData* MapTree::mutable_leafs(int index) {
  return leafs_.Mutable(index);
}
inline ::MapData* MapTree::add_leafs() {
  return leafs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapData >&
MapTree::leafs() const {
  return leafs_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapData >*
MapTree::mutable_leafs() {
  return &leafs_;
}

// optional uint64 baseId = 10;
inline bool MapTree::has_baseid() const {
  return _has_bit(8);
}
inline void MapTree::clear_baseid() {
  baseid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(8);
}
inline ::google::protobuf::uint64 MapTree::baseid() const {
  return baseid_;
}
inline void MapTree::set_baseid(::google::protobuf::uint64 value) {
  _set_bit(8);
  baseid_ = value;
}

// optional .StringTable stringTable = 11;
inline bool MapTree::has_stringtable() const {
  return _has_bit(9);
}
inline void MapTree::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::StringTable::Clear();
  _clear_bit(9);
}
inline const ::StringTable& MapTree::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::StringTable* MapTree::mutable_stringtable() {
  _set_bit(9);
  if (stringtable_ == NULL) stringtable_ = new ::StringTable;
  return stringtable_;
}

// -------------------------------------------------------------------

// MapData

// required bytes coordinates = 1;
inline bool MapData::has_coordinates() const {
  return _has_bit(0);
}
inline void MapData::clear_coordinates() {
  if (coordinates_ != &_default_coordinates_) {
    coordinates_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MapData::coordinates() const {
  return *coordinates_;
}
inline void MapData::set_coordinates(const ::std::string& value) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
}
inline void MapData::set_coordinates(const char* value) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
}
inline void MapData::set_coordinates(const void* value, size_t size) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_coordinates() {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  return coordinates_;
}

// required bytes types = 2;
inline bool MapData::has_types() const {
  return _has_bit(1);
}
inline void MapData::clear_types() {
  if (types_ != &_default_types_) {
    types_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MapData::types() const {
  return *types_;
}
inline void MapData::set_types(const ::std::string& value) {
  _set_bit(1);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void MapData::set_types(const char* value) {
  _set_bit(1);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void MapData::set_types(const void* value, size_t size) {
  _set_bit(1);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_types() {
  _set_bit(1);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  return types_;
}

// required sint64 id = 3;
inline bool MapData::has_id() const {
  return _has_bit(2);
}
inline void MapData::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 MapData::id() const {
  return id_;
}
inline void MapData::set_id(::google::protobuf::int64 value) {
  _set_bit(2);
  id_ = value;
}

// optional uint32 stringId = 4;
inline bool MapData::has_stringid() const {
  return _has_bit(3);
}
inline void MapData::clear_stringid() {
  stringid_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 MapData::stringid() const {
  return stringid_;
}
inline void MapData::set_stringid(::google::protobuf::uint32 value) {
  _set_bit(3);
  stringid_ = value;
}

// optional bytes restrictions = 5;
inline bool MapData::has_restrictions() const {
  return _has_bit(4);
}
inline void MapData::clear_restrictions() {
  if (restrictions_ != &_default_restrictions_) {
    restrictions_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MapData::restrictions() const {
  return *restrictions_;
}
inline void MapData::set_restrictions(const ::std::string& value) {
  _set_bit(4);
  if (restrictions_ == &_default_restrictions_) {
    restrictions_ = new ::std::string;
  }
  restrictions_->assign(value);
}
inline void MapData::set_restrictions(const char* value) {
  _set_bit(4);
  if (restrictions_ == &_default_restrictions_) {
    restrictions_ = new ::std::string;
  }
  restrictions_->assign(value);
}
inline void MapData::set_restrictions(const void* value, size_t size) {
  _set_bit(4);
  if (restrictions_ == &_default_restrictions_) {
    restrictions_ = new ::std::string;
  }
  restrictions_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_restrictions() {
  _set_bit(4);
  if (restrictions_ == &_default_restrictions_) {
    restrictions_ = new ::std::string;
  }
  return restrictions_;
}

// optional int32 highwayMeta = 6;
inline bool MapData::has_highwaymeta() const {
  return _has_bit(5);
}
inline void MapData::clear_highwaymeta() {
  highwaymeta_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 MapData::highwaymeta() const {
  return highwaymeta_;
}
inline void MapData::set_highwaymeta(::google::protobuf::int32 value) {
  _set_bit(5);
  highwaymeta_ = value;
}

// -------------------------------------------------------------------

// OsmAndAddressIndex

// required string name = 1;
inline bool OsmAndAddressIndex::has_name() const {
  return _has_bit(0);
}
inline void OsmAndAddressIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndAddressIndex::name() const {
  return *name_;
}
inline void OsmAndAddressIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndAddressIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndAddressIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndAddressIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool OsmAndAddressIndex::has_name_en() const {
  return _has_bit(1);
}
inline void OsmAndAddressIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OsmAndAddressIndex::name_en() const {
  return *name_en_;
}
inline void OsmAndAddressIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void OsmAndAddressIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void OsmAndAddressIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndAddressIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional .CitiesIndex cities = 5;
inline bool OsmAndAddressIndex::has_cities() const {
  return _has_bit(2);
}
inline void OsmAndAddressIndex::clear_cities() {
  if (cities_ != NULL) cities_->::CitiesIndex::Clear();
  _clear_bit(2);
}
inline const ::CitiesIndex& OsmAndAddressIndex::cities() const {
  return cities_ != NULL ? *cities_ : *default_instance_->cities_;
}
inline ::CitiesIndex* OsmAndAddressIndex::mutable_cities() {
  _set_bit(2);
  if (cities_ == NULL) cities_ = new ::CitiesIndex;
  return cities_;
}

// optional .PostcodesIndex postcodes = 6;
inline bool OsmAndAddressIndex::has_postcodes() const {
  return _has_bit(3);
}
inline void OsmAndAddressIndex::clear_postcodes() {
  if (postcodes_ != NULL) postcodes_->::PostcodesIndex::Clear();
  _clear_bit(3);
}
inline const ::PostcodesIndex& OsmAndAddressIndex::postcodes() const {
  return postcodes_ != NULL ? *postcodes_ : *default_instance_->postcodes_;
}
inline ::PostcodesIndex* OsmAndAddressIndex::mutable_postcodes() {
  _set_bit(3);
  if (postcodes_ == NULL) postcodes_ = new ::PostcodesIndex;
  return postcodes_;
}

// optional .CitiesIndex villages = 7;
inline bool OsmAndAddressIndex::has_villages() const {
  return _has_bit(4);
}
inline void OsmAndAddressIndex::clear_villages() {
  if (villages_ != NULL) villages_->::CitiesIndex::Clear();
  _clear_bit(4);
}
inline const ::CitiesIndex& OsmAndAddressIndex::villages() const {
  return villages_ != NULL ? *villages_ : *default_instance_->villages_;
}
inline ::CitiesIndex* OsmAndAddressIndex::mutable_villages() {
  _set_bit(4);
  if (villages_ == NULL) villages_ = new ::CitiesIndex;
  return villages_;
}

// -------------------------------------------------------------------

// CitiesIndex

// repeated .CityIndex cities = 1;
inline int CitiesIndex::cities_size() const {
  return cities_.size();
}
inline void CitiesIndex::clear_cities() {
  cities_.Clear();
}
inline const ::CityIndex& CitiesIndex::cities(int index) const {
  return cities_.Get(index);
}
inline ::CityIndex* CitiesIndex::mutable_cities(int index) {
  return cities_.Mutable(index);
}
inline ::CityIndex* CitiesIndex::add_cities() {
  return cities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CityIndex >&
CitiesIndex::cities() const {
  return cities_;
}
inline ::google::protobuf::RepeatedPtrField< ::CityIndex >*
CitiesIndex::mutable_cities() {
  return &cities_;
}

// -------------------------------------------------------------------

// PostcodesIndex

// repeated .PostcodeIndex postcodes = 1;
inline int PostcodesIndex::postcodes_size() const {
  return postcodes_.size();
}
inline void PostcodesIndex::clear_postcodes() {
  postcodes_.Clear();
}
inline const ::PostcodeIndex& PostcodesIndex::postcodes(int index) const {
  return postcodes_.Get(index);
}
inline ::PostcodeIndex* PostcodesIndex::mutable_postcodes(int index) {
  return postcodes_.Mutable(index);
}
inline ::PostcodeIndex* PostcodesIndex::add_postcodes() {
  return postcodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PostcodeIndex >&
PostcodesIndex::postcodes() const {
  return postcodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::PostcodeIndex >*
PostcodesIndex::mutable_postcodes() {
  return &postcodes_;
}

// -------------------------------------------------------------------

// CityIndex

// required uint32 city_type = 1;
inline bool CityIndex::has_city_type() const {
  return _has_bit(0);
}
inline void CityIndex::clear_city_type() {
  city_type_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CityIndex::city_type() const {
  return city_type_;
}
inline void CityIndex::set_city_type(::google::protobuf::uint32 value) {
  _set_bit(0);
  city_type_ = value;
}

// required string name = 2;
inline bool CityIndex::has_name() const {
  return _has_bit(1);
}
inline void CityIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CityIndex::name() const {
  return *name_;
}
inline void CityIndex::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CityIndex::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CityIndex::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 3;
inline bool CityIndex::has_name_en() const {
  return _has_bit(2);
}
inline void CityIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CityIndex::name_en() const {
  return *name_en_;
}
inline void CityIndex::set_name_en(const ::std::string& value) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void CityIndex::set_name_en(const char* value) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void CityIndex::set_name_en(const char* value, size_t size) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::mutable_name_en() {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional uint64 id = 4;
inline bool CityIndex::has_id() const {
  return _has_bit(3);
}
inline void CityIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 CityIndex::id() const {
  return id_;
}
inline void CityIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(3);
  id_ = value;
}

// required fixed32 x = 5;
inline bool CityIndex::has_x() const {
  return _has_bit(4);
}
inline void CityIndex::clear_x() {
  x_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 CityIndex::x() const {
  return x_;
}
inline void CityIndex::set_x(::google::protobuf::uint32 value) {
  _set_bit(4);
  x_ = value;
}

// required fixed32 y = 6;
inline bool CityIndex::has_y() const {
  return _has_bit(5);
}
inline void CityIndex::clear_y() {
  y_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 CityIndex::y() const {
  return y_;
}
inline void CityIndex::set_y(::google::protobuf::uint32 value) {
  _set_bit(5);
  y_ = value;
}

// optional .InteresectedStreets intersections = 14;
inline bool CityIndex::has_intersections() const {
  return _has_bit(6);
}
inline void CityIndex::clear_intersections() {
  if (intersections_ != NULL) intersections_->::InteresectedStreets::Clear();
  _clear_bit(6);
}
inline const ::InteresectedStreets& CityIndex::intersections() const {
  return intersections_ != NULL ? *intersections_ : *default_instance_->intersections_;
}
inline ::InteresectedStreets* CityIndex::mutable_intersections() {
  _set_bit(6);
  if (intersections_ == NULL) intersections_ = new ::InteresectedStreets;
  return intersections_;
}

// repeated .StreetIndex streets = 18;
inline int CityIndex::streets_size() const {
  return streets_.size();
}
inline void CityIndex::clear_streets() {
  streets_.Clear();
}
inline const ::StreetIndex& CityIndex::streets(int index) const {
  return streets_.Get(index);
}
inline ::StreetIndex* CityIndex::mutable_streets(int index) {
  return streets_.Mutable(index);
}
inline ::StreetIndex* CityIndex::add_streets() {
  return streets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StreetIndex >&
CityIndex::streets() const {
  return streets_;
}
inline ::google::protobuf::RepeatedPtrField< ::StreetIndex >*
CityIndex::mutable_streets() {
  return &streets_;
}

// -------------------------------------------------------------------

// InteresectedStreets

// repeated .StreetIntersection intersections = 5;
inline int InteresectedStreets::intersections_size() const {
  return intersections_.size();
}
inline void InteresectedStreets::clear_intersections() {
  intersections_.Clear();
}
inline const ::StreetIntersection& InteresectedStreets::intersections(int index) const {
  return intersections_.Get(index);
}
inline ::StreetIntersection* InteresectedStreets::mutable_intersections(int index) {
  return intersections_.Mutable(index);
}
inline ::StreetIntersection* InteresectedStreets::add_intersections() {
  return intersections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StreetIntersection >&
InteresectedStreets::intersections() const {
  return intersections_;
}
inline ::google::protobuf::RepeatedPtrField< ::StreetIntersection >*
InteresectedStreets::mutable_intersections() {
  return &intersections_;
}

// -------------------------------------------------------------------

// StreetIntersection

// required uint32 intersectedStreet1 = 2;
inline bool StreetIntersection::has_intersectedstreet1() const {
  return _has_bit(0);
}
inline void StreetIntersection::clear_intersectedstreet1() {
  intersectedstreet1_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StreetIntersection::intersectedstreet1() const {
  return intersectedstreet1_;
}
inline void StreetIntersection::set_intersectedstreet1(::google::protobuf::uint32 value) {
  _set_bit(0);
  intersectedstreet1_ = value;
}

// required uint32 intersectedStreet2 = 3;
inline bool StreetIntersection::has_intersectedstreet2() const {
  return _has_bit(1);
}
inline void StreetIntersection::clear_intersectedstreet2() {
  intersectedstreet2_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 StreetIntersection::intersectedstreet2() const {
  return intersectedstreet2_;
}
inline void StreetIntersection::set_intersectedstreet2(::google::protobuf::uint32 value) {
  _set_bit(1);
  intersectedstreet2_ = value;
}

// required sint32 intersectedX = 4;
inline bool StreetIntersection::has_intersectedx() const {
  return _has_bit(2);
}
inline void StreetIntersection::clear_intersectedx() {
  intersectedx_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 StreetIntersection::intersectedx() const {
  return intersectedx_;
}
inline void StreetIntersection::set_intersectedx(::google::protobuf::int32 value) {
  _set_bit(2);
  intersectedx_ = value;
}

// required sint32 intersectedY = 5;
inline bool StreetIntersection::has_intersectedy() const {
  return _has_bit(3);
}
inline void StreetIntersection::clear_intersectedy() {
  intersectedy_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 StreetIntersection::intersectedy() const {
  return intersectedy_;
}
inline void StreetIntersection::set_intersectedy(::google::protobuf::int32 value) {
  _set_bit(3);
  intersectedy_ = value;
}

// -------------------------------------------------------------------

// PostcodeIndex

// required string postcode = 1;
inline bool PostcodeIndex::has_postcode() const {
  return _has_bit(0);
}
inline void PostcodeIndex::clear_postcode() {
  if (postcode_ != &_default_postcode_) {
    postcode_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PostcodeIndex::postcode() const {
  return *postcode_;
}
inline void PostcodeIndex::set_postcode(const ::std::string& value) {
  _set_bit(0);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void PostcodeIndex::set_postcode(const char* value) {
  _set_bit(0);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void PostcodeIndex::set_postcode(const char* value, size_t size) {
  _set_bit(0);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostcodeIndex::mutable_postcode() {
  _set_bit(0);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  return postcode_;
}

// required fixed32 x = 2;
inline bool PostcodeIndex::has_x() const {
  return _has_bit(1);
}
inline void PostcodeIndex::clear_x() {
  x_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 PostcodeIndex::x() const {
  return x_;
}
inline void PostcodeIndex::set_x(::google::protobuf::uint32 value) {
  _set_bit(1);
  x_ = value;
}

// required fixed32 y = 3;
inline bool PostcodeIndex::has_y() const {
  return _has_bit(2);
}
inline void PostcodeIndex::clear_y() {
  y_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 PostcodeIndex::y() const {
  return y_;
}
inline void PostcodeIndex::set_y(::google::protobuf::uint32 value) {
  _set_bit(2);
  y_ = value;
}

// repeated .StreetIndex streets = 5;
inline int PostcodeIndex::streets_size() const {
  return streets_.size();
}
inline void PostcodeIndex::clear_streets() {
  streets_.Clear();
}
inline const ::StreetIndex& PostcodeIndex::streets(int index) const {
  return streets_.Get(index);
}
inline ::StreetIndex* PostcodeIndex::mutable_streets(int index) {
  return streets_.Mutable(index);
}
inline ::StreetIndex* PostcodeIndex::add_streets() {
  return streets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StreetIndex >&
PostcodeIndex::streets() const {
  return streets_;
}
inline ::google::protobuf::RepeatedPtrField< ::StreetIndex >*
PostcodeIndex::mutable_streets() {
  return &streets_;
}

// -------------------------------------------------------------------

// StreetIndex

// required string name = 1;
inline bool StreetIndex::has_name() const {
  return _has_bit(0);
}
inline void StreetIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StreetIndex::name() const {
  return *name_;
}
inline void StreetIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool StreetIndex::has_name_en() const {
  return _has_bit(1);
}
inline void StreetIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StreetIndex::name_en() const {
  return *name_en_;
}
inline void StreetIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// required sint32 x = 3;
inline bool StreetIndex::has_x() const {
  return _has_bit(2);
}
inline void StreetIndex::clear_x() {
  x_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 StreetIndex::x() const {
  return x_;
}
inline void StreetIndex::set_x(::google::protobuf::int32 value) {
  _set_bit(2);
  x_ = value;
}

// required sint32 y = 4;
inline bool StreetIndex::has_y() const {
  return _has_bit(3);
}
inline void StreetIndex::clear_y() {
  y_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 StreetIndex::y() const {
  return y_;
}
inline void StreetIndex::set_y(::google::protobuf::int32 value) {
  _set_bit(3);
  y_ = value;
}

// optional uint64 id = 6;
inline bool StreetIndex::has_id() const {
  return _has_bit(4);
}
inline void StreetIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 StreetIndex::id() const {
  return id_;
}
inline void StreetIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(4);
  id_ = value;
}

// repeated .BuildingIndex buildings = 18;
inline int StreetIndex::buildings_size() const {
  return buildings_.size();
}
inline void StreetIndex::clear_buildings() {
  buildings_.Clear();
}
inline const ::BuildingIndex& StreetIndex::buildings(int index) const {
  return buildings_.Get(index);
}
inline ::BuildingIndex* StreetIndex::mutable_buildings(int index) {
  return buildings_.Mutable(index);
}
inline ::BuildingIndex* StreetIndex::add_buildings() {
  return buildings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
StreetIndex::buildings() const {
  return buildings_;
}
inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
StreetIndex::mutable_buildings() {
  return &buildings_;
}

// -------------------------------------------------------------------

// BuildingIndex

// required string name = 1;
inline bool BuildingIndex::has_name() const {
  return _has_bit(0);
}
inline void BuildingIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BuildingIndex::name() const {
  return *name_;
}
inline void BuildingIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BuildingIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BuildingIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool BuildingIndex::has_name_en() const {
  return _has_bit(1);
}
inline void BuildingIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BuildingIndex::name_en() const {
  return *name_en_;
}
inline void BuildingIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void BuildingIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void BuildingIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional uint64 id = 5;
inline bool BuildingIndex::has_id() const {
  return _has_bit(2);
}
inline void BuildingIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 BuildingIndex::id() const {
  return id_;
}
inline void BuildingIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(2);
  id_ = value;
}

// optional string postcode = 6;
inline bool BuildingIndex::has_postcode() const {
  return _has_bit(3);
}
inline void BuildingIndex::clear_postcode() {
  if (postcode_ != &_default_postcode_) {
    postcode_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& BuildingIndex::postcode() const {
  return *postcode_;
}
inline void BuildingIndex::set_postcode(const ::std::string& value) {
  _set_bit(3);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void BuildingIndex::set_postcode(const char* value) {
  _set_bit(3);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void BuildingIndex::set_postcode(const char* value, size_t size) {
  _set_bit(3);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_postcode() {
  _set_bit(3);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  return postcode_;
}

// required sint32 x = 3;
inline bool BuildingIndex::has_x() const {
  return _has_bit(4);
}
inline void BuildingIndex::clear_x() {
  x_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 BuildingIndex::x() const {
  return x_;
}
inline void BuildingIndex::set_x(::google::protobuf::int32 value) {
  _set_bit(4);
  x_ = value;
}

// required sint32 y = 4;
inline bool BuildingIndex::has_y() const {
  return _has_bit(5);
}
inline void BuildingIndex::clear_y() {
  y_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 BuildingIndex::y() const {
  return y_;
}
inline void BuildingIndex::set_y(::google::protobuf::int32 value) {
  _set_bit(5);
  y_ = value;
}

// -------------------------------------------------------------------

// TransportRoutes

// repeated .TransportRoute routes = 6;
inline int TransportRoutes::routes_size() const {
  return routes_.size();
}
inline void TransportRoutes::clear_routes() {
  routes_.Clear();
}
inline const ::TransportRoute& TransportRoutes::routes(int index) const {
  return routes_.Get(index);
}
inline ::TransportRoute* TransportRoutes::mutable_routes(int index) {
  return routes_.Mutable(index);
}
inline ::TransportRoute* TransportRoutes::add_routes() {
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRoute >&
TransportRoutes::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRoute >*
TransportRoutes::mutable_routes() {
  return &routes_;
}

// -------------------------------------------------------------------

// TransportRoute

// required uint64 id = 1;
inline bool TransportRoute::has_id() const {
  return _has_bit(0);
}
inline void TransportRoute::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 TransportRoute::id() const {
  return id_;
}
inline void TransportRoute::set_id(::google::protobuf::uint64 value) {
  _set_bit(0);
  id_ = value;
}

// optional uint32 type = 3;
inline bool TransportRoute::has_type() const {
  return _has_bit(1);
}
inline void TransportRoute::clear_type() {
  type_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 TransportRoute::type() const {
  return type_;
}
inline void TransportRoute::set_type(::google::protobuf::uint32 value) {
  _set_bit(1);
  type_ = value;
}

// optional uint32 operator = 4;
inline bool TransportRoute::has_operator_() const {
  return _has_bit(2);
}
inline void TransportRoute::clear_operator_() {
  operator__ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 TransportRoute::operator_() const {
  return operator__;
}
inline void TransportRoute::set_operator_(::google::protobuf::uint32 value) {
  _set_bit(2);
  operator__ = value;
}

// optional string ref = 5;
inline bool TransportRoute::has_ref() const {
  return _has_bit(3);
}
inline void TransportRoute::clear_ref() {
  if (ref_ != &_default_ref_) {
    ref_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& TransportRoute::ref() const {
  return *ref_;
}
inline void TransportRoute::set_ref(const ::std::string& value) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void TransportRoute::set_ref(const char* value) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void TransportRoute::set_ref(const char* value, size_t size) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRoute::mutable_ref() {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  return ref_;
}

// optional uint32 name = 6;
inline bool TransportRoute::has_name() const {
  return _has_bit(4);
}
inline void TransportRoute::clear_name() {
  name_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportRoute::name() const {
  return name_;
}
inline void TransportRoute::set_name(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportRoute::has_name_en() const {
  return _has_bit(5);
}
inline void TransportRoute::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 TransportRoute::name_en() const {
  return name_en_;
}
inline void TransportRoute::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(5);
  name_en_ = value;
}

// optional uint32 distance = 8;
inline bool TransportRoute::has_distance() const {
  return _has_bit(6);
}
inline void TransportRoute::clear_distance() {
  distance_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 TransportRoute::distance() const {
  return distance_;
}
inline void TransportRoute::set_distance(::google::protobuf::uint32 value) {
  _set_bit(6);
  distance_ = value;
}

// repeated .TransportRouteStop directStops = 15;
inline int TransportRoute::directstops_size() const {
  return directstops_.size();
}
inline void TransportRoute::clear_directstops() {
  directstops_.Clear();
}
inline const ::TransportRouteStop& TransportRoute::directstops(int index) const {
  return directstops_.Get(index);
}
inline ::TransportRouteStop* TransportRoute::mutable_directstops(int index) {
  return directstops_.Mutable(index);
}
inline ::TransportRouteStop* TransportRoute::add_directstops() {
  return directstops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
TransportRoute::directstops() const {
  return directstops_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
TransportRoute::mutable_directstops() {
  return &directstops_;
}

// repeated .TransportRouteStop reverseStops = 16;
inline int TransportRoute::reversestops_size() const {
  return reversestops_.size();
}
inline void TransportRoute::clear_reversestops() {
  reversestops_.Clear();
}
inline const ::TransportRouteStop& TransportRoute::reversestops(int index) const {
  return reversestops_.Get(index);
}
inline ::TransportRouteStop* TransportRoute::mutable_reversestops(int index) {
  return reversestops_.Mutable(index);
}
inline ::TransportRouteStop* TransportRoute::add_reversestops() {
  return reversestops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
TransportRoute::reversestops() const {
  return reversestops_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
TransportRoute::mutable_reversestops() {
  return &reversestops_;
}

// -------------------------------------------------------------------

// TransportRouteStop

// required sint64 id = 1;
inline bool TransportRouteStop::has_id() const {
  return _has_bit(0);
}
inline void TransportRouteStop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 TransportRouteStop::id() const {
  return id_;
}
inline void TransportRouteStop::set_id(::google::protobuf::int64 value) {
  _set_bit(0);
  id_ = value;
}

// required sint32 dx = 2;
inline bool TransportRouteStop::has_dx() const {
  return _has_bit(1);
}
inline void TransportRouteStop::clear_dx() {
  dx_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportRouteStop::dx() const {
  return dx_;
}
inline void TransportRouteStop::set_dx(::google::protobuf::int32 value) {
  _set_bit(1);
  dx_ = value;
}

// required sint32 dy = 3;
inline bool TransportRouteStop::has_dy() const {
  return _has_bit(2);
}
inline void TransportRouteStop::clear_dy() {
  dy_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 TransportRouteStop::dy() const {
  return dy_;
}
inline void TransportRouteStop::set_dy(::google::protobuf::int32 value) {
  _set_bit(2);
  dy_ = value;
}

// required uint32 name = 6;
inline bool TransportRouteStop::has_name() const {
  return _has_bit(3);
}
inline void TransportRouteStop::clear_name() {
  name_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 TransportRouteStop::name() const {
  return name_;
}
inline void TransportRouteStop::set_name(::google::protobuf::uint32 value) {
  _set_bit(3);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportRouteStop::has_name_en() const {
  return _has_bit(4);
}
inline void TransportRouteStop::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportRouteStop::name_en() const {
  return name_en_;
}
inline void TransportRouteStop::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_en_ = value;
}

// -------------------------------------------------------------------

// TransportStop

// required sint32 dx = 1;
inline bool TransportStop::has_dx() const {
  return _has_bit(0);
}
inline void TransportStop::clear_dx() {
  dx_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TransportStop::dx() const {
  return dx_;
}
inline void TransportStop::set_dx(::google::protobuf::int32 value) {
  _set_bit(0);
  dx_ = value;
}

// required sint32 dy = 2;
inline bool TransportStop::has_dy() const {
  return _has_bit(1);
}
inline void TransportStop::clear_dy() {
  dy_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportStop::dy() const {
  return dy_;
}
inline void TransportStop::set_dy(::google::protobuf::int32 value) {
  _set_bit(1);
  dy_ = value;
}

// required sint64 id = 5;
inline bool TransportStop::has_id() const {
  return _has_bit(2);
}
inline void TransportStop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 TransportStop::id() const {
  return id_;
}
inline void TransportStop::set_id(::google::protobuf::int64 value) {
  _set_bit(2);
  id_ = value;
}

// required uint32 name = 6;
inline bool TransportStop::has_name() const {
  return _has_bit(3);
}
inline void TransportStop::clear_name() {
  name_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 TransportStop::name() const {
  return name_;
}
inline void TransportStop::set_name(::google::protobuf::uint32 value) {
  _set_bit(3);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportStop::has_name_en() const {
  return _has_bit(4);
}
inline void TransportStop::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportStop::name_en() const {
  return name_en_;
}
inline void TransportStop::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_en_ = value;
}

// repeated uint32 routes = 16;
inline int TransportStop::routes_size() const {
  return routes_.size();
}
inline void TransportStop::clear_routes() {
  routes_.Clear();
}
inline ::google::protobuf::uint32 TransportStop::routes(int index) const {
  return routes_.Get(index);
}
inline void TransportStop::set_routes(int index, ::google::protobuf::uint32 value) {
  routes_.Set(index, value);
}
inline void TransportStop::add_routes(::google::protobuf::uint32 value) {
  routes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportStop::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportStop::mutable_routes() {
  return &routes_;
}

// -------------------------------------------------------------------

// TransportStopsTree

// required sint32 left = 1;
inline bool TransportStopsTree::has_left() const {
  return _has_bit(0);
}
inline void TransportStopsTree::clear_left() {
  left_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TransportStopsTree::left() const {
  return left_;
}
inline void TransportStopsTree::set_left(::google::protobuf::int32 value) {
  _set_bit(0);
  left_ = value;
}

// required sint32 right = 2;
inline bool TransportStopsTree::has_right() const {
  return _has_bit(1);
}
inline void TransportStopsTree::clear_right() {
  right_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportStopsTree::right() const {
  return right_;
}
inline void TransportStopsTree::set_right(::google::protobuf::int32 value) {
  _set_bit(1);
  right_ = value;
}

// required sint32 top = 3;
inline bool TransportStopsTree::has_top() const {
  return _has_bit(2);
}
inline void TransportStopsTree::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 TransportStopsTree::top() const {
  return top_;
}
inline void TransportStopsTree::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// required sint32 bottom = 4;
inline bool TransportStopsTree::has_bottom() const {
  return _has_bit(3);
}
inline void TransportStopsTree::clear_bottom() {
  bottom_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 TransportStopsTree::bottom() const {
  return bottom_;
}
inline void TransportStopsTree::set_bottom(::google::protobuf::int32 value) {
  _set_bit(3);
  bottom_ = value;
}

// repeated .TransportStopsTree subtrees = 7;
inline int TransportStopsTree::subtrees_size() const {
  return subtrees_.size();
}
inline void TransportStopsTree::clear_subtrees() {
  subtrees_.Clear();
}
inline const ::TransportStopsTree& TransportStopsTree::subtrees(int index) const {
  return subtrees_.Get(index);
}
inline ::TransportStopsTree* TransportStopsTree::mutable_subtrees(int index) {
  return subtrees_.Mutable(index);
}
inline ::TransportStopsTree* TransportStopsTree::add_subtrees() {
  return subtrees_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >&
TransportStopsTree::subtrees() const {
  return subtrees_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >*
TransportStopsTree::mutable_subtrees() {
  return &subtrees_;
}

// repeated .TransportStop leafs = 8;
inline int TransportStopsTree::leafs_size() const {
  return leafs_.size();
}
inline void TransportStopsTree::clear_leafs() {
  leafs_.Clear();
}
inline const ::TransportStop& TransportStopsTree::leafs(int index) const {
  return leafs_.Get(index);
}
inline ::TransportStop* TransportStopsTree::mutable_leafs(int index) {
  return leafs_.Mutable(index);
}
inline ::TransportStop* TransportStopsTree::add_leafs() {
  return leafs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportStop >&
TransportStopsTree::leafs() const {
  return leafs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportStop >*
TransportStopsTree::mutable_leafs() {
  return &leafs_;
}

// optional uint64 baseId = 16;
inline bool TransportStopsTree::has_baseid() const {
  return _has_bit(6);
}
inline void TransportStopsTree::clear_baseid() {
  baseid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::uint64 TransportStopsTree::baseid() const {
  return baseid_;
}
inline void TransportStopsTree::set_baseid(::google::protobuf::uint64 value) {
  _set_bit(6);
  baseid_ = value;
}

// -------------------------------------------------------------------

// OsmAndTransportIndex

// optional string name = 1;
inline bool OsmAndTransportIndex::has_name() const {
  return _has_bit(0);
}
inline void OsmAndTransportIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndTransportIndex::name() const {
  return *name_;
}
inline void OsmAndTransportIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndTransportIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndTransportIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndTransportIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional .TransportRoutes routes = 3;
inline bool OsmAndTransportIndex::has_routes() const {
  return _has_bit(1);
}
inline void OsmAndTransportIndex::clear_routes() {
  if (routes_ != NULL) routes_->::TransportRoutes::Clear();
  _clear_bit(1);
}
inline const ::TransportRoutes& OsmAndTransportIndex::routes() const {
  return routes_ != NULL ? *routes_ : *default_instance_->routes_;
}
inline ::TransportRoutes* OsmAndTransportIndex::mutable_routes() {
  _set_bit(1);
  if (routes_ == NULL) routes_ = new ::TransportRoutes;
  return routes_;
}

// optional .TransportStopsTree stops = 6;
inline bool OsmAndTransportIndex::has_stops() const {
  return _has_bit(2);
}
inline void OsmAndTransportIndex::clear_stops() {
  if (stops_ != NULL) stops_->::TransportStopsTree::Clear();
  _clear_bit(2);
}
inline const ::TransportStopsTree& OsmAndTransportIndex::stops() const {
  return stops_ != NULL ? *stops_ : *default_instance_->stops_;
}
inline ::TransportStopsTree* OsmAndTransportIndex::mutable_stops() {
  _set_bit(2);
  if (stops_ == NULL) stops_ = new ::TransportStopsTree;
  return stops_;
}

// required .StringTable stringTable = 9;
inline bool OsmAndTransportIndex::has_stringtable() const {
  return _has_bit(3);
}
inline void OsmAndTransportIndex::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::StringTable::Clear();
  _clear_bit(3);
}
inline const ::StringTable& OsmAndTransportIndex::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::StringTable* OsmAndTransportIndex::mutable_stringtable() {
  _set_bit(3);
  if (stringtable_ == NULL) stringtable_ = new ::StringTable;
  return stringtable_;
}

// -------------------------------------------------------------------

// OsmAndTileBox

// required uint32 left = 1;
inline bool OsmAndTileBox::has_left() const {
  return _has_bit(0);
}
inline void OsmAndTileBox::clear_left() {
  left_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndTileBox::left() const {
  return left_;
}
inline void OsmAndTileBox::set_left(::google::protobuf::uint32 value) {
  _set_bit(0);
  left_ = value;
}

// required uint32 right = 2;
inline bool OsmAndTileBox::has_right() const {
  return _has_bit(1);
}
inline void OsmAndTileBox::clear_right() {
  right_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 OsmAndTileBox::right() const {
  return right_;
}
inline void OsmAndTileBox::set_right(::google::protobuf::uint32 value) {
  _set_bit(1);
  right_ = value;
}

// required uint32 top = 3;
inline bool OsmAndTileBox::has_top() const {
  return _has_bit(2);
}
inline void OsmAndTileBox::clear_top() {
  top_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 OsmAndTileBox::top() const {
  return top_;
}
inline void OsmAndTileBox::set_top(::google::protobuf::uint32 value) {
  _set_bit(2);
  top_ = value;
}

// required uint32 bottom = 4;
inline bool OsmAndTileBox::has_bottom() const {
  return _has_bit(3);
}
inline void OsmAndTileBox::clear_bottom() {
  bottom_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 OsmAndTileBox::bottom() const {
  return bottom_;
}
inline void OsmAndTileBox::set_bottom(::google::protobuf::uint32 value) {
  _set_bit(3);
  bottom_ = value;
}

// -------------------------------------------------------------------

// OsmAndPoiIndex

// required string name = 1;
inline bool OsmAndPoiIndex::has_name() const {
  return _has_bit(0);
}
inline void OsmAndPoiIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndPoiIndex::name() const {
  return *name_;
}
inline void OsmAndPoiIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .OsmAndTileBox boundaries = 2;
inline bool OsmAndPoiIndex::has_boundaries() const {
  return _has_bit(1);
}
inline void OsmAndPoiIndex::clear_boundaries() {
  if (boundaries_ != NULL) boundaries_->::OsmAndTileBox::Clear();
  _clear_bit(1);
}
inline const ::OsmAndTileBox& OsmAndPoiIndex::boundaries() const {
  return boundaries_ != NULL ? *boundaries_ : *default_instance_->boundaries_;
}
inline ::OsmAndTileBox* OsmAndPoiIndex::mutable_boundaries() {
  _set_bit(1);
  if (boundaries_ == NULL) boundaries_ = new ::OsmAndTileBox;
  return boundaries_;
}

// repeated .OsmAndCategoryTable categoriesTable = 3;
inline int OsmAndPoiIndex::categoriestable_size() const {
  return categoriestable_.size();
}
inline void OsmAndPoiIndex::clear_categoriestable() {
  categoriestable_.Clear();
}
inline const ::OsmAndCategoryTable& OsmAndPoiIndex::categoriestable(int index) const {
  return categoriestable_.Get(index);
}
inline ::OsmAndCategoryTable* OsmAndPoiIndex::mutable_categoriestable(int index) {
  return categoriestable_.Mutable(index);
}
inline ::OsmAndCategoryTable* OsmAndPoiIndex::add_categoriestable() {
  return categoriestable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable >&
OsmAndPoiIndex::categoriestable() const {
  return categoriestable_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable >*
OsmAndPoiIndex::mutable_categoriestable() {
  return &categoriestable_;
}

// optional .OsmAndPoiNameIndex nameIndex = 4;
inline bool OsmAndPoiIndex::has_nameindex() const {
  return _has_bit(3);
}
inline void OsmAndPoiIndex::clear_nameindex() {
  if (nameindex_ != NULL) nameindex_->::OsmAndPoiNameIndex::Clear();
  _clear_bit(3);
}
inline const ::OsmAndPoiNameIndex& OsmAndPoiIndex::nameindex() const {
  return nameindex_ != NULL ? *nameindex_ : *default_instance_->nameindex_;
}
inline ::OsmAndPoiNameIndex* OsmAndPoiIndex::mutable_nameindex() {
  _set_bit(3);
  if (nameindex_ == NULL) nameindex_ = new ::OsmAndPoiNameIndex;
  return nameindex_;
}

// repeated .OsmAndPoiBox boxes = 6;
inline int OsmAndPoiIndex::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndPoiIndex::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAndPoiBox& OsmAndPoiIndex::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAndPoiBox* OsmAndPoiIndex::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAndPoiBox* OsmAndPoiIndex::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >&
OsmAndPoiIndex::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >*
OsmAndPoiIndex::mutable_boxes() {
  return &boxes_;
}

// repeated .OsmAndPoiBoxData poiData = 9;
inline int OsmAndPoiIndex::poidata_size() const {
  return poidata_.size();
}
inline void OsmAndPoiIndex::clear_poidata() {
  poidata_.Clear();
}
inline const ::OsmAndPoiBoxData& OsmAndPoiIndex::poidata(int index) const {
  return poidata_.Get(index);
}
inline ::OsmAndPoiBoxData* OsmAndPoiIndex::mutable_poidata(int index) {
  return poidata_.Mutable(index);
}
inline ::OsmAndPoiBoxData* OsmAndPoiIndex::add_poidata() {
  return poidata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData >&
OsmAndPoiIndex::poidata() const {
  return poidata_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData >*
OsmAndPoiIndex::mutable_poidata() {
  return &poidata_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndex

// required .IndexedStringTable table = 2;
inline bool OsmAndPoiNameIndex::has_table() const {
  return _has_bit(0);
}
inline void OsmAndPoiNameIndex::clear_table() {
  if (table_ != NULL) table_->::IndexedStringTable::Clear();
  _clear_bit(0);
}
inline const ::IndexedStringTable& OsmAndPoiNameIndex::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::IndexedStringTable* OsmAndPoiNameIndex::mutable_table() {
  _set_bit(0);
  if (table_ == NULL) table_ = new ::IndexedStringTable;
  return table_;
}

// repeated .OsmAndPoiNameIndexData data = 5;
inline int OsmAndPoiNameIndex::data_size() const {
  return data_.size();
}
inline void OsmAndPoiNameIndex::clear_data() {
  data_.Clear();
}
inline const ::OsmAndPoiNameIndexData& OsmAndPoiNameIndex::data(int index) const {
  return data_.Get(index);
}
inline ::OsmAndPoiNameIndexData* OsmAndPoiNameIndex::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::OsmAndPoiNameIndexData* OsmAndPoiNameIndex::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexData >&
OsmAndPoiNameIndex::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexData >*
OsmAndPoiNameIndex::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndexData

// repeated .OsmAndPoiNameIndexDataAtom atoms = 4;
inline int OsmAndPoiNameIndexData::atoms_size() const {
  return atoms_.size();
}
inline void OsmAndPoiNameIndexData::clear_atoms() {
  atoms_.Clear();
}
inline const ::OsmAndPoiNameIndexDataAtom& OsmAndPoiNameIndexData::atoms(int index) const {
  return atoms_.Get(index);
}
inline ::OsmAndPoiNameIndexDataAtom* OsmAndPoiNameIndexData::mutable_atoms(int index) {
  return atoms_.Mutable(index);
}
inline ::OsmAndPoiNameIndexDataAtom* OsmAndPoiNameIndexData::add_atoms() {
  return atoms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom >&
OsmAndPoiNameIndexData::atoms() const {
  return atoms_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom >*
OsmAndPoiNameIndexData::mutable_atoms() {
  return &atoms_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndexDataAtom

// optional uint32 zoom = 2;
inline bool OsmAndPoiNameIndexDataAtom::has_zoom() const {
  return _has_bit(0);
}
inline void OsmAndPoiNameIndexDataAtom::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::zoom() const {
  return zoom_;
}
inline void OsmAndPoiNameIndexDataAtom::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// optional uint32 x = 3;
inline bool OsmAndPoiNameIndexDataAtom::has_x() const {
  return _has_bit(1);
}
inline void OsmAndPoiNameIndexDataAtom::clear_x() {
  x_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::x() const {
  return x_;
}
inline void OsmAndPoiNameIndexDataAtom::set_x(::google::protobuf::uint32 value) {
  _set_bit(1);
  x_ = value;
}

// optional uint32 y = 4;
inline bool OsmAndPoiNameIndexDataAtom::has_y() const {
  return _has_bit(2);
}
inline void OsmAndPoiNameIndexDataAtom::clear_y() {
  y_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::y() const {
  return y_;
}
inline void OsmAndPoiNameIndexDataAtom::set_y(::google::protobuf::uint32 value) {
  _set_bit(2);
  y_ = value;
}

// optional fixed32 shiftTo = 14;
inline bool OsmAndPoiNameIndexDataAtom::has_shiftto() const {
  return _has_bit(3);
}
inline void OsmAndPoiNameIndexDataAtom::clear_shiftto() {
  shiftto_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::shiftto() const {
  return shiftto_;
}
inline void OsmAndPoiNameIndexDataAtom::set_shiftto(::google::protobuf::uint32 value) {
  _set_bit(3);
  shiftto_ = value;
}

// -------------------------------------------------------------------

// OsmAndCategoryTable

// required string category = 1;
inline bool OsmAndCategoryTable::has_category() const {
  return _has_bit(0);
}
inline void OsmAndCategoryTable::clear_category() {
  if (category_ != &_default_category_) {
    category_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndCategoryTable::category() const {
  return *category_;
}
inline void OsmAndCategoryTable::set_category(const ::std::string& value) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void OsmAndCategoryTable::set_category(const char* value) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void OsmAndCategoryTable::set_category(const char* value, size_t size) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndCategoryTable::mutable_category() {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  return category_;
}

// repeated string subcategories = 3;
inline int OsmAndCategoryTable::subcategories_size() const {
  return subcategories_.size();
}
inline void OsmAndCategoryTable::clear_subcategories() {
  subcategories_.Clear();
}
inline const ::std::string& OsmAndCategoryTable::subcategories(int index) const {
  return subcategories_.Get(index);
}
inline ::std::string* OsmAndCategoryTable::mutable_subcategories(int index) {
  return subcategories_.Mutable(index);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const ::std::string& value) {
  subcategories_.Mutable(index)->assign(value);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const char* value) {
  subcategories_.Mutable(index)->assign(value);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const char* value, size_t size) {
  subcategories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndCategoryTable::add_subcategories() {
  return subcategories_.Add();
}
inline void OsmAndCategoryTable::add_subcategories(const ::std::string& value) {
  subcategories_.Add()->assign(value);
}
inline void OsmAndCategoryTable::add_subcategories(const char* value) {
  subcategories_.Add()->assign(value);
}
inline void OsmAndCategoryTable::add_subcategories(const char* value, size_t size) {
  subcategories_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OsmAndCategoryTable::subcategories() const {
  return subcategories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OsmAndCategoryTable::mutable_subcategories() {
  return &subcategories_;
}

// -------------------------------------------------------------------

// OsmAndPoiBox

// required uint32 zoom = 1;
inline bool OsmAndPoiBox::has_zoom() const {
  return _has_bit(0);
}
inline void OsmAndPoiBox::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndPoiBox::zoom() const {
  return zoom_;
}
inline void OsmAndPoiBox::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// required sint32 left = 2;
inline bool OsmAndPoiBox::has_left() const {
  return _has_bit(1);
}
inline void OsmAndPoiBox::clear_left() {
  left_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 OsmAndPoiBox::left() const {
  return left_;
}
inline void OsmAndPoiBox::set_left(::google::protobuf::int32 value) {
  _set_bit(1);
  left_ = value;
}

// required sint32 top = 3;
inline bool OsmAndPoiBox::has_top() const {
  return _has_bit(2);
}
inline void OsmAndPoiBox::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 OsmAndPoiBox::top() const {
  return top_;
}
inline void OsmAndPoiBox::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// optional .OsmAndPoiCategories categories = 4;
inline bool OsmAndPoiBox::has_categories() const {
  return _has_bit(3);
}
inline void OsmAndPoiBox::clear_categories() {
  if (categories_ != NULL) categories_->::OsmAndPoiCategories::Clear();
  _clear_bit(3);
}
inline const ::OsmAndPoiCategories& OsmAndPoiBox::categories() const {
  return categories_ != NULL ? *categories_ : *default_instance_->categories_;
}
inline ::OsmAndPoiCategories* OsmAndPoiBox::mutable_categories() {
  _set_bit(3);
  if (categories_ == NULL) categories_ = new ::OsmAndPoiCategories;
  return categories_;
}

// repeated .OsmAndPoiBox subBoxes = 10;
inline int OsmAndPoiBox::subboxes_size() const {
  return subboxes_.size();
}
inline void OsmAndPoiBox::clear_subboxes() {
  subboxes_.Clear();
}
inline const ::OsmAndPoiBox& OsmAndPoiBox::subboxes(int index) const {
  return subboxes_.Get(index);
}
inline ::OsmAndPoiBox* OsmAndPoiBox::mutable_subboxes(int index) {
  return subboxes_.Mutable(index);
}
inline ::OsmAndPoiBox* OsmAndPoiBox::add_subboxes() {
  return subboxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >&
OsmAndPoiBox::subboxes() const {
  return subboxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >*
OsmAndPoiBox::mutable_subboxes() {
  return &subboxes_;
}

// optional fixed32 shiftToData = 14;
inline bool OsmAndPoiBox::has_shifttodata() const {
  return _has_bit(5);
}
inline void OsmAndPoiBox::clear_shifttodata() {
  shifttodata_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 OsmAndPoiBox::shifttodata() const {
  return shifttodata_;
}
inline void OsmAndPoiBox::set_shifttodata(::google::protobuf::uint32 value) {
  _set_bit(5);
  shifttodata_ = value;
}

// -------------------------------------------------------------------

// OsmAndPoiCategories

// repeated uint32 categories = 3;
inline int OsmAndPoiCategories::categories_size() const {
  return categories_.size();
}
inline void OsmAndPoiCategories::clear_categories() {
  categories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiCategories::categories(int index) const {
  return categories_.Get(index);
}
inline void OsmAndPoiCategories::set_categories(int index, ::google::protobuf::uint32 value) {
  categories_.Set(index, value);
}
inline void OsmAndPoiCategories::add_categories(::google::protobuf::uint32 value) {
  categories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiCategories::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiCategories::mutable_categories() {
  return &categories_;
}

// -------------------------------------------------------------------

// OsmAndPoiBoxData

// optional uint32 zoom = 1;
inline bool OsmAndPoiBoxData::has_zoom() const {
  return _has_bit(0);
}
inline void OsmAndPoiBoxData::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::zoom() const {
  return zoom_;
}
inline void OsmAndPoiBoxData::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// optional uint32 x = 2;
inline bool OsmAndPoiBoxData::has_x() const {
  return _has_bit(1);
}
inline void OsmAndPoiBoxData::clear_x() {
  x_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::x() const {
  return x_;
}
inline void OsmAndPoiBoxData::set_x(::google::protobuf::uint32 value) {
  _set_bit(1);
  x_ = value;
}

// optional uint32 y = 3;
inline bool OsmAndPoiBoxData::has_y() const {
  return _has_bit(2);
}
inline void OsmAndPoiBoxData::clear_y() {
  y_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::y() const {
  return y_;
}
inline void OsmAndPoiBoxData::set_y(::google::protobuf::uint32 value) {
  _set_bit(2);
  y_ = value;
}

// repeated .OsmAndPoiBoxDataAtom poiData = 5;
inline int OsmAndPoiBoxData::poidata_size() const {
  return poidata_.size();
}
inline void OsmAndPoiBoxData::clear_poidata() {
  poidata_.Clear();
}
inline const ::OsmAndPoiBoxDataAtom& OsmAndPoiBoxData::poidata(int index) const {
  return poidata_.Get(index);
}
inline ::OsmAndPoiBoxDataAtom* OsmAndPoiBoxData::mutable_poidata(int index) {
  return poidata_.Mutable(index);
}
inline ::OsmAndPoiBoxDataAtom* OsmAndPoiBoxData::add_poidata() {
  return poidata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom >&
OsmAndPoiBoxData::poidata() const {
  return poidata_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom >*
OsmAndPoiBoxData::mutable_poidata() {
  return &poidata_;
}

// -------------------------------------------------------------------

// OsmAndPoiBoxDataAtom

// required sint32 dx = 2;
inline bool OsmAndPoiBoxDataAtom::has_dx() const {
  return _has_bit(0);
}
inline void OsmAndPoiBoxDataAtom::clear_dx() {
  dx_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 OsmAndPoiBoxDataAtom::dx() const {
  return dx_;
}
inline void OsmAndPoiBoxDataAtom::set_dx(::google::protobuf::int32 value) {
  _set_bit(0);
  dx_ = value;
}

// required sint32 dy = 3;
inline bool OsmAndPoiBoxDataAtom::has_dy() const {
  return _has_bit(1);
}
inline void OsmAndPoiBoxDataAtom::clear_dy() {
  dy_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 OsmAndPoiBoxDataAtom::dy() const {
  return dy_;
}
inline void OsmAndPoiBoxDataAtom::set_dy(::google::protobuf::int32 value) {
  _set_bit(1);
  dy_ = value;
}

// repeated uint32 categories = 4;
inline int OsmAndPoiBoxDataAtom::categories_size() const {
  return categories_.size();
}
inline void OsmAndPoiBoxDataAtom::clear_categories() {
  categories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxDataAtom::categories(int index) const {
  return categories_.Get(index);
}
inline void OsmAndPoiBoxDataAtom::set_categories(int index, ::google::protobuf::uint32 value) {
  categories_.Set(index, value);
}
inline void OsmAndPoiBoxDataAtom::add_categories(::google::protobuf::uint32 value) {
  categories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiBoxDataAtom::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiBoxDataAtom::mutable_categories() {
  return &categories_;
}

// optional string name = 6;
inline bool OsmAndPoiBoxDataAtom::has_name() const {
  return _has_bit(3);
}
inline void OsmAndPoiBoxDataAtom::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::name() const {
  return *name_;
}
inline void OsmAndPoiBoxDataAtom::set_name(const ::std::string& value) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_name(const char* value) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_name(const char* value, size_t size) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_name() {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string nameEn = 7;
inline bool OsmAndPoiBoxDataAtom::has_nameen() const {
  return _has_bit(4);
}
inline void OsmAndPoiBoxDataAtom::clear_nameen() {
  if (nameen_ != &_default_nameen_) {
    nameen_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::nameen() const {
  return *nameen_;
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const ::std::string& value) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const char* value) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const char* value, size_t size) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_nameen() {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  return nameen_;
}

// optional uint64 id = 8;
inline bool OsmAndPoiBoxDataAtom::has_id() const {
  return _has_bit(5);
}
inline void OsmAndPoiBoxDataAtom::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 OsmAndPoiBoxDataAtom::id() const {
  return id_;
}
inline void OsmAndPoiBoxDataAtom::set_id(::google::protobuf::uint64 value) {
  _set_bit(5);
  id_ = value;
}

// optional string openingHours = 10;
inline bool OsmAndPoiBoxDataAtom::has_openinghours() const {
  return _has_bit(6);
}
inline void OsmAndPoiBoxDataAtom::clear_openinghours() {
  if (openinghours_ != &_default_openinghours_) {
    openinghours_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::openinghours() const {
  return *openinghours_;
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const ::std::string& value) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const char* value) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const char* value, size_t size) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_openinghours() {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  return openinghours_;
}

// optional string site = 11;
inline bool OsmAndPoiBoxDataAtom::has_site() const {
  return _has_bit(7);
}
inline void OsmAndPoiBoxDataAtom::clear_site() {
  if (site_ != &_default_site_) {
    site_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::site() const {
  return *site_;
}
inline void OsmAndPoiBoxDataAtom::set_site(const ::std::string& value) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_site(const char* value) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_site(const char* value, size_t size) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_site() {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  return site_;
}

// optional string phone = 12;
inline bool OsmAndPoiBoxDataAtom::has_phone() const {
  return _has_bit(8);
}
inline void OsmAndPoiBoxDataAtom::clear_phone() {
  if (phone_ != &_default_phone_) {
    phone_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::phone() const {
  return *phone_;
}
inline void OsmAndPoiBoxDataAtom::set_phone(const ::std::string& value) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_phone(const char* value) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_phone(const char* value, size_t size) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_phone() {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  return phone_;
}

// optional string note = 13;
inline bool OsmAndPoiBoxDataAtom::has_note() const {
  return _has_bit(9);
}
inline void OsmAndPoiBoxDataAtom::clear_note() {
  if (note_ != &_default_note_) {
    note_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::note() const {
  return *note_;
}
inline void OsmAndPoiBoxDataAtom::set_note(const ::std::string& value) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_note(const char* value) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_note(const char* value, size_t size) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_note() {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  return note_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_osmand_5fodb_2eproto__INCLUDED
