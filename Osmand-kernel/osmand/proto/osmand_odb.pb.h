// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/osmand_odb.proto

#ifndef PROTOBUF_src_2fosmand_5fodb_2eproto__INCLUDED
#define PROTOBUF_src_2fosmand_5fodb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();

class OsmAndStructure;
class OsmAndTileBox;
class StringTable;
class IndexedStringTable;
class OsmAndMapIndex;
class OsmAndMapIndex_MapEncodingRule;
class OsmAndMapIndex_MapRootLevel;
class OsmAndMapIndex_MapDataBox;
class MapDataBlock;
class MapData;
class OsmAndAddressIndex;
class OsmAndAddressIndex_CitiesIndex;
class OsmAndAddressNameIndexData;
class OsmAndAddressNameIndexData_AddressNameIndexData;
class AddressNameIndexDataAtom;
class CityIndex;
class CityBlockIndex;
class StreetIndex;
class StreetIntersection;
class BuildingIndex;
class TransportRoutes;
class TransportRoute;
class TransportRouteStop;
class TransportStop;
class TransportStopsTree;
class OsmAndTransportIndex;
class OsmAndPoiIndex;
class OsmAndPoiNameIndex;
class OsmAndPoiNameIndex_OsmAndPoiNameIndexData;
class OsmAndPoiNameIndexDataAtom;
class OsmAndCategoryTable;
class OsmAndPoiBox;
class OsmAndPoiCategories;
class OsmAndPoiBoxData;
class OsmAndPoiBoxDataAtom;

// ===================================================================

class OsmAndStructure : public ::google::protobuf::Message {
 public:
  OsmAndStructure();
  virtual ~OsmAndStructure();
  
  OsmAndStructure(const OsmAndStructure& from);
  
  inline OsmAndStructure& operator=(const OsmAndStructure& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndStructure& default_instance();
  
  void Swap(OsmAndStructure* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndStructure& from);
  void MergeFrom(const OsmAndStructure& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // required int64 dateCreated = 18;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 18;
  inline ::google::protobuf::int64 datecreated() const;
  inline void set_datecreated(::google::protobuf::int64 value);
  
  // repeated .OsmAndAddressIndex addressIndex = 7;
  inline int addressindex_size() const;
  inline void clear_addressindex();
  static const int kAddressIndexFieldNumber = 7;
  inline const ::OsmAndAddressIndex& addressindex(int index) const;
  inline ::OsmAndAddressIndex* mutable_addressindex(int index);
  inline ::OsmAndAddressIndex* add_addressindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex >&
      addressindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex >*
      mutable_addressindex();
  
  // repeated .OsmAndTransportIndex transportIndex = 4;
  inline int transportindex_size() const;
  inline void clear_transportindex();
  static const int kTransportIndexFieldNumber = 4;
  inline const ::OsmAndTransportIndex& transportindex(int index) const;
  inline ::OsmAndTransportIndex* mutable_transportindex(int index);
  inline ::OsmAndTransportIndex* add_transportindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex >&
      transportindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex >*
      mutable_transportindex();
  
  // repeated .OsmAndPoiIndex poiIndex = 8;
  inline int poiindex_size() const;
  inline void clear_poiindex();
  static const int kPoiIndexFieldNumber = 8;
  inline const ::OsmAndPoiIndex& poiindex(int index) const;
  inline ::OsmAndPoiIndex* mutable_poiindex(int index);
  inline ::OsmAndPoiIndex* add_poiindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex >&
      poiindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex >*
      mutable_poiindex();
  
  // repeated .OsmAndMapIndex mapIndex = 6;
  inline int mapindex_size() const;
  inline void clear_mapindex();
  static const int kMapIndexFieldNumber = 6;
  inline const ::OsmAndMapIndex& mapindex(int index) const;
  inline ::OsmAndMapIndex* mutable_mapindex(int index);
  inline ::OsmAndMapIndex* add_mapindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex >&
      mapindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex >*
      mutable_mapindex();
  
  // required uint32 versionConfirm = 32;
  inline bool has_versionconfirm() const;
  inline void clear_versionconfirm();
  static const int kVersionConfirmFieldNumber = 32;
  inline ::google::protobuf::uint32 versionconfirm() const;
  inline void set_versionconfirm(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndStructure)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 version_;
  ::google::protobuf::int64 datecreated_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex > addressindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex > transportindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex > poiindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex > mapindex_;
  ::google::protobuf::uint32 versionconfirm_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndStructure* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndTileBox : public ::google::protobuf::Message {
 public:
  OsmAndTileBox();
  virtual ~OsmAndTileBox();
  
  OsmAndTileBox(const OsmAndTileBox& from);
  
  inline OsmAndTileBox& operator=(const OsmAndTileBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndTileBox& default_instance();
  
  void Swap(OsmAndTileBox* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndTileBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndTileBox& from);
  void MergeFrom(const OsmAndTileBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::uint32 left() const;
  inline void set_left(::google::protobuf::uint32 value);
  
  // required uint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::uint32 right() const;
  inline void set_right(::google::protobuf::uint32 value);
  
  // required uint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::uint32 top() const;
  inline void set_top(::google::protobuf::uint32 value);
  
  // required uint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::uint32 bottom() const;
  inline void set_bottom(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndTileBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 left_;
  ::google::protobuf::uint32 right_;
  ::google::protobuf::uint32 top_;
  ::google::protobuf::uint32 bottom_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndTileBox* default_instance_;
};
// -------------------------------------------------------------------

class StringTable : public ::google::protobuf::Message {
 public:
  StringTable();
  virtual ~StringTable();
  
  StringTable(const StringTable& from);
  
  inline StringTable& operator=(const StringTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringTable& default_instance();
  
  void Swap(StringTable* other);
  
  // implements Message ----------------------------------------------
  
  StringTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringTable& from);
  void MergeFrom(const StringTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string s = 1;
  inline int s_size() const;
  inline void clear_s();
  static const int kSFieldNumber = 1;
  inline const ::std::string& s(int index) const;
  inline ::std::string* mutable_s(int index);
  inline void set_s(int index, const ::std::string& value);
  inline void set_s(int index, const char* value);
  inline void set_s(int index, const char* value, size_t size);
  inline ::std::string* add_s();
  inline void add_s(const ::std::string& value);
  inline void add_s(const char* value);
  inline void add_s(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& s() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_s();
  
  // @@protoc_insertion_point(class_scope:StringTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> s_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StringTable* default_instance_;
};
// -------------------------------------------------------------------

class IndexedStringTable : public ::google::protobuf::Message {
 public:
  IndexedStringTable();
  virtual ~IndexedStringTable();
  
  IndexedStringTable(const IndexedStringTable& from);
  
  inline IndexedStringTable& operator=(const IndexedStringTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexedStringTable& default_instance();
  
  void Swap(IndexedStringTable* other);
  
  // implements Message ----------------------------------------------
  
  IndexedStringTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexedStringTable& from);
  void MergeFrom(const IndexedStringTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  
  // repeated string key = 3;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key(int index) const;
  inline ::std::string* mutable_key(int index);
  inline void set_key(int index, const ::std::string& value);
  inline void set_key(int index, const char* value);
  inline void set_key(int index, const char* value, size_t size);
  inline ::std::string* add_key();
  inline void add_key(const ::std::string& value);
  inline void add_key(const char* value);
  inline void add_key(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key();
  
  // repeated fixed32 val = 4;
  inline int val_size() const;
  inline void clear_val();
  static const int kValFieldNumber = 4;
  inline ::google::protobuf::uint32 val(int index) const;
  inline void set_val(int index, ::google::protobuf::uint32 value);
  inline void add_val(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      val() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_val();
  
  // repeated .IndexedStringTable subtables = 5;
  inline int subtables_size() const;
  inline void clear_subtables();
  static const int kSubtablesFieldNumber = 5;
  inline const ::IndexedStringTable& subtables(int index) const;
  inline ::IndexedStringTable* mutable_subtables(int index);
  inline ::IndexedStringTable* add_subtables();
  inline const ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >&
      subtables() const;
  inline ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >*
      mutable_subtables();
  
  // @@protoc_insertion_point(class_scope:IndexedStringTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* prefix_;
  static const ::std::string _default_prefix_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > val_;
  ::google::protobuf::RepeatedPtrField< ::IndexedStringTable > subtables_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IndexedStringTable* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex_MapEncodingRule : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex_MapEncodingRule();
  virtual ~OsmAndMapIndex_MapEncodingRule();
  
  OsmAndMapIndex_MapEncodingRule(const OsmAndMapIndex_MapEncodingRule& from);
  
  inline OsmAndMapIndex_MapEncodingRule& operator=(const OsmAndMapIndex_MapEncodingRule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex_MapEncodingRule& default_instance();
  
  void Swap(OsmAndMapIndex_MapEncodingRule* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndMapIndex_MapEncodingRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex_MapEncodingRule& from);
  void MergeFrom(const OsmAndMapIndex_MapEncodingRule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // optional string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // optional uint32 id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 minZoom = 9;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinZoomFieldNumber = 9;
  inline ::google::protobuf::uint32 minzoom() const;
  inline void set_minzoom(::google::protobuf::uint32 value);
  
  // optional uint32 type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndMapIndex.MapEncodingRule)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 minzoom_;
  ::google::protobuf::uint32 type_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndMapIndex_MapEncodingRule* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex_MapRootLevel : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex_MapRootLevel();
  virtual ~OsmAndMapIndex_MapRootLevel();
  
  OsmAndMapIndex_MapRootLevel(const OsmAndMapIndex_MapRootLevel& from);
  
  inline OsmAndMapIndex_MapRootLevel& operator=(const OsmAndMapIndex_MapRootLevel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex_MapRootLevel& default_instance();
  
  void Swap(OsmAndMapIndex_MapRootLevel* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndMapIndex_MapRootLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex_MapRootLevel& from);
  void MergeFrom(const OsmAndMapIndex_MapRootLevel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 maxZoom = 1;
  inline bool has_maxzoom() const;
  inline void clear_maxzoom();
  static const int kMaxZoomFieldNumber = 1;
  inline ::google::protobuf::int32 maxzoom() const;
  inline void set_maxzoom(::google::protobuf::int32 value);
  
  // required int32 minZoom = 2;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinZoomFieldNumber = 2;
  inline ::google::protobuf::int32 minzoom() const;
  inline void set_minzoom(::google::protobuf::int32 value);
  
  // required int32 left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required int32 right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required int32 top = 5;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 5;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required int32 bottom = 6;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 6;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // repeated .OsmAndMapIndex.MapDataBox boxes = 7;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 7;
  inline const ::OsmAndMapIndex_MapDataBox& boxes(int index) const;
  inline ::OsmAndMapIndex_MapDataBox* mutable_boxes(int index);
  inline ::OsmAndMapIndex_MapDataBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox >*
      mutable_boxes();
  
  // repeated .MapDataBlock blocks = 15;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 15;
  inline const ::MapDataBlock& blocks(int index) const;
  inline ::MapDataBlock* mutable_blocks(int index);
  inline ::MapDataBlock* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataBlock >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataBlock >*
      mutable_blocks();
  
  // @@protoc_insertion_point(class_scope:OsmAndMapIndex.MapRootLevel)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 maxzoom_;
  ::google::protobuf::int32 minzoom_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::MapDataBlock > blocks_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndMapIndex_MapRootLevel* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex_MapDataBox : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex_MapDataBox();
  virtual ~OsmAndMapIndex_MapDataBox();
  
  OsmAndMapIndex_MapDataBox(const OsmAndMapIndex_MapDataBox& from);
  
  inline OsmAndMapIndex_MapDataBox& operator=(const OsmAndMapIndex_MapDataBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex_MapDataBox& default_instance();
  
  void Swap(OsmAndMapIndex_MapDataBox* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndMapIndex_MapDataBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex_MapDataBox& from);
  void MergeFrom(const OsmAndMapIndex_MapDataBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // optional fixed32 shiftToMapData = 5;
  inline bool has_shifttomapdata() const;
  inline void clear_shifttomapdata();
  static const int kShiftToMapDataFieldNumber = 5;
  inline ::google::protobuf::uint32 shifttomapdata() const;
  inline void set_shifttomapdata(::google::protobuf::uint32 value);
  
  // optional bool ocean = 6;
  inline bool has_ocean() const;
  inline void clear_ocean();
  static const int kOceanFieldNumber = 6;
  inline bool ocean() const;
  inline void set_ocean(bool value);
  
  // repeated .OsmAndMapIndex.MapDataBox boxes = 7;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 7;
  inline const ::OsmAndMapIndex_MapDataBox& boxes(int index) const;
  inline ::OsmAndMapIndex_MapDataBox* mutable_boxes(int index);
  inline ::OsmAndMapIndex_MapDataBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox >*
      mutable_boxes();
  
  // @@protoc_insertion_point(class_scope:OsmAndMapIndex.MapDataBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::uint32 shifttomapdata_;
  bool ocean_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox > boxes_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndMapIndex_MapDataBox* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex();
  virtual ~OsmAndMapIndex();
  
  OsmAndMapIndex(const OsmAndMapIndex& from);
  
  inline OsmAndMapIndex& operator=(const OsmAndMapIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex& default_instance();
  
  void Swap(OsmAndMapIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndMapIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex& from);
  void MergeFrom(const OsmAndMapIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OsmAndMapIndex_MapEncodingRule MapEncodingRule;
  typedef OsmAndMapIndex_MapRootLevel MapRootLevel;
  typedef OsmAndMapIndex_MapDataBox MapDataBox;
  
  // accessors -------------------------------------------------------
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated .OsmAndMapIndex.MapEncodingRule rules = 4;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 4;
  inline const ::OsmAndMapIndex_MapEncodingRule& rules(int index) const;
  inline ::OsmAndMapIndex_MapEncodingRule* mutable_rules(int index);
  inline ::OsmAndMapIndex_MapEncodingRule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapEncodingRule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapEncodingRule >*
      mutable_rules();
  
  // repeated .OsmAndMapIndex.MapRootLevel levels = 5;
  inline int levels_size() const;
  inline void clear_levels();
  static const int kLevelsFieldNumber = 5;
  inline const ::OsmAndMapIndex_MapRootLevel& levels(int index) const;
  inline ::OsmAndMapIndex_MapRootLevel* mutable_levels(int index);
  inline ::OsmAndMapIndex_MapRootLevel* add_levels();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapRootLevel >&
      levels() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapRootLevel >*
      mutable_levels();
  
  // @@protoc_insertion_point(class_scope:OsmAndMapIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapEncodingRule > rules_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapRootLevel > levels_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndMapIndex* default_instance_;
};
// -------------------------------------------------------------------

class MapDataBlock : public ::google::protobuf::Message {
 public:
  MapDataBlock();
  virtual ~MapDataBlock();
  
  MapDataBlock(const MapDataBlock& from);
  
  inline MapDataBlock& operator=(const MapDataBlock& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataBlock& default_instance();
  
  void Swap(MapDataBlock* other);
  
  // implements Message ----------------------------------------------
  
  MapDataBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataBlock& from);
  void MergeFrom(const MapDataBlock& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 baseId = 10;
  inline bool has_baseid() const;
  inline void clear_baseid();
  static const int kBaseIdFieldNumber = 10;
  inline ::google::protobuf::uint64 baseid() const;
  inline void set_baseid(::google::protobuf::uint64 value);
  
  // repeated .MapData dataObjects = 12;
  inline int dataobjects_size() const;
  inline void clear_dataobjects();
  static const int kDataObjectsFieldNumber = 12;
  inline const ::MapData& dataobjects(int index) const;
  inline ::MapData* mutable_dataobjects(int index);
  inline ::MapData* add_dataobjects();
  inline const ::google::protobuf::RepeatedPtrField< ::MapData >&
      dataobjects() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapData >*
      mutable_dataobjects();
  
  // optional .StringTable stringTable = 15;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 15;
  inline const ::StringTable& stringtable() const;
  inline ::StringTable* mutable_stringtable();
  
  // @@protoc_insertion_point(class_scope:MapDataBlock)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 baseid_;
  ::google::protobuf::RepeatedPtrField< ::MapData > dataobjects_;
  ::StringTable* stringtable_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MapDataBlock* default_instance_;
};
// -------------------------------------------------------------------

class MapData : public ::google::protobuf::Message {
 public:
  MapData();
  virtual ~MapData();
  
  MapData(const MapData& from);
  
  inline MapData& operator=(const MapData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapData& default_instance();
  
  void Swap(MapData* other);
  
  // implements Message ----------------------------------------------
  
  MapData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapData& from);
  void MergeFrom(const MapData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes coordinates = 1;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 1;
  inline const ::std::string& coordinates() const;
  inline void set_coordinates(const ::std::string& value);
  inline void set_coordinates(const char* value);
  inline void set_coordinates(const void* value, size_t size);
  inline ::std::string* mutable_coordinates();
  
  // optional bytes areaCoordinates = 2;
  inline bool has_areacoordinates() const;
  inline void clear_areacoordinates();
  static const int kAreaCoordinatesFieldNumber = 2;
  inline const ::std::string& areacoordinates() const;
  inline void set_areacoordinates(const ::std::string& value);
  inline void set_areacoordinates(const char* value);
  inline void set_areacoordinates(const void* value, size_t size);
  inline ::std::string* mutable_areacoordinates();
  
  // repeated bytes polygonInnerCoordinates = 4;
  inline int polygoninnercoordinates_size() const;
  inline void clear_polygoninnercoordinates();
  static const int kPolygonInnerCoordinatesFieldNumber = 4;
  inline const ::std::string& polygoninnercoordinates(int index) const;
  inline ::std::string* mutable_polygoninnercoordinates(int index);
  inline void set_polygoninnercoordinates(int index, const ::std::string& value);
  inline void set_polygoninnercoordinates(int index, const char* value);
  inline void set_polygoninnercoordinates(int index, const void* value, size_t size);
  inline ::std::string* add_polygoninnercoordinates();
  inline void add_polygoninnercoordinates(const ::std::string& value);
  inline void add_polygoninnercoordinates(const char* value);
  inline void add_polygoninnercoordinates(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& polygoninnercoordinates() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_polygoninnercoordinates();
  
  // optional bytes additionalTypes = 6;
  inline bool has_additionaltypes() const;
  inline void clear_additionaltypes();
  static const int kAdditionalTypesFieldNumber = 6;
  inline const ::std::string& additionaltypes() const;
  inline void set_additionaltypes(const ::std::string& value);
  inline void set_additionaltypes(const char* value);
  inline void set_additionaltypes(const void* value, size_t size);
  inline ::std::string* mutable_additionaltypes();
  
  // required bytes types = 7;
  inline bool has_types() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 7;
  inline const ::std::string& types() const;
  inline void set_types(const ::std::string& value);
  inline void set_types(const char* value);
  inline void set_types(const void* value, size_t size);
  inline ::std::string* mutable_types();
  
  // optional bytes stringNames = 10;
  inline bool has_stringnames() const;
  inline void clear_stringnames();
  static const int kStringNamesFieldNumber = 10;
  inline const ::std::string& stringnames() const;
  inline void set_stringnames(const ::std::string& value);
  inline void set_stringnames(const char* value);
  inline void set_stringnames(const void* value, size_t size);
  inline ::std::string* mutable_stringnames();
  
  // required sint64 id = 12;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 12;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // optional bytes rasterBytes = 15;
  inline bool has_rasterbytes() const;
  inline void clear_rasterbytes();
  static const int kRasterBytesFieldNumber = 15;
  inline const ::std::string& rasterbytes() const;
  inline void set_rasterbytes(const ::std::string& value);
  inline void set_rasterbytes(const char* value);
  inline void set_rasterbytes(const void* value, size_t size);
  inline ::std::string* mutable_rasterbytes();
  
  // @@protoc_insertion_point(class_scope:MapData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* coordinates_;
  static const ::std::string _default_coordinates_;
  ::std::string* areacoordinates_;
  static const ::std::string _default_areacoordinates_;
  ::google::protobuf::RepeatedPtrField< ::std::string> polygoninnercoordinates_;
  ::std::string* additionaltypes_;
  static const ::std::string _default_additionaltypes_;
  ::std::string* types_;
  static const ::std::string _default_types_;
  ::std::string* stringnames_;
  static const ::std::string _default_stringnames_;
  ::google::protobuf::int64 id_;
  ::std::string* rasterbytes_;
  static const ::std::string _default_rasterbytes_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MapData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressIndex_CitiesIndex : public ::google::protobuf::Message {
 public:
  OsmAndAddressIndex_CitiesIndex();
  virtual ~OsmAndAddressIndex_CitiesIndex();
  
  OsmAndAddressIndex_CitiesIndex(const OsmAndAddressIndex_CitiesIndex& from);
  
  inline OsmAndAddressIndex_CitiesIndex& operator=(const OsmAndAddressIndex_CitiesIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressIndex_CitiesIndex& default_instance();
  
  void Swap(OsmAndAddressIndex_CitiesIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndAddressIndex_CitiesIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressIndex_CitiesIndex& from);
  void MergeFrom(const OsmAndAddressIndex_CitiesIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // repeated .CityIndex cities = 5;
  inline int cities_size() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 5;
  inline const ::CityIndex& cities(int index) const;
  inline ::CityIndex* mutable_cities(int index);
  inline ::CityIndex* add_cities();
  inline const ::google::protobuf::RepeatedPtrField< ::CityIndex >&
      cities() const;
  inline ::google::protobuf::RepeatedPtrField< ::CityIndex >*
      mutable_cities();
  
  // repeated .CityBlockIndex blocks = 7;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 7;
  inline const ::CityBlockIndex& blocks(int index) const;
  inline ::CityBlockIndex* mutable_blocks(int index);
  inline ::CityBlockIndex* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::CityBlockIndex >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::CityBlockIndex >*
      mutable_blocks();
  
  // @@protoc_insertion_point(class_scope:OsmAndAddressIndex.CitiesIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 type_;
  ::google::protobuf::RepeatedPtrField< ::CityIndex > cities_;
  ::google::protobuf::RepeatedPtrField< ::CityBlockIndex > blocks_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndAddressIndex_CitiesIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressIndex : public ::google::protobuf::Message {
 public:
  OsmAndAddressIndex();
  virtual ~OsmAndAddressIndex();
  
  OsmAndAddressIndex(const OsmAndAddressIndex& from);
  
  inline OsmAndAddressIndex& operator=(const OsmAndAddressIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressIndex& default_instance();
  
  void Swap(OsmAndAddressIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndAddressIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressIndex& from);
  void MergeFrom(const OsmAndAddressIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OsmAndAddressIndex_CitiesIndex CitiesIndex;
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional .OsmAndTileBox boundaries = 3;
  inline bool has_boundaries() const;
  inline void clear_boundaries();
  static const int kBoundariesFieldNumber = 3;
  inline const ::OsmAndTileBox& boundaries() const;
  inline ::OsmAndTileBox* mutable_boundaries();
  
  // repeated .OsmAndAddressIndex.CitiesIndex cities = 6;
  inline int cities_size() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 6;
  inline const ::OsmAndAddressIndex_CitiesIndex& cities(int index) const;
  inline ::OsmAndAddressIndex_CitiesIndex* mutable_cities(int index);
  inline ::OsmAndAddressIndex_CitiesIndex* add_cities();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex_CitiesIndex >&
      cities() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex_CitiesIndex >*
      mutable_cities();
  
  // optional .OsmAndAddressNameIndexData nameIndex = 7;
  inline bool has_nameindex() const;
  inline void clear_nameindex();
  static const int kNameIndexFieldNumber = 7;
  inline const ::OsmAndAddressNameIndexData& nameindex() const;
  inline ::OsmAndAddressNameIndexData* mutable_nameindex();
  
  // @@protoc_insertion_point(class_scope:OsmAndAddressIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::OsmAndTileBox* boundaries_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex_CitiesIndex > cities_;
  ::OsmAndAddressNameIndexData* nameindex_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndAddressIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressNameIndexData_AddressNameIndexData : public ::google::protobuf::Message {
 public:
  OsmAndAddressNameIndexData_AddressNameIndexData();
  virtual ~OsmAndAddressNameIndexData_AddressNameIndexData();
  
  OsmAndAddressNameIndexData_AddressNameIndexData(const OsmAndAddressNameIndexData_AddressNameIndexData& from);
  
  inline OsmAndAddressNameIndexData_AddressNameIndexData& operator=(const OsmAndAddressNameIndexData_AddressNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressNameIndexData_AddressNameIndexData& default_instance();
  
  void Swap(OsmAndAddressNameIndexData_AddressNameIndexData* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndAddressNameIndexData_AddressNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressNameIndexData_AddressNameIndexData& from);
  void MergeFrom(const OsmAndAddressNameIndexData_AddressNameIndexData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .AddressNameIndexDataAtom atom = 4;
  inline int atom_size() const;
  inline void clear_atom();
  static const int kAtomFieldNumber = 4;
  inline const ::AddressNameIndexDataAtom& atom(int index) const;
  inline ::AddressNameIndexDataAtom* mutable_atom(int index);
  inline ::AddressNameIndexDataAtom* add_atom();
  inline const ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom >&
      atom() const;
  inline ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom >*
      mutable_atom();
  
  // @@protoc_insertion_point(class_scope:OsmAndAddressNameIndexData.AddressNameIndexData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom > atom_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndAddressNameIndexData_AddressNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressNameIndexData : public ::google::protobuf::Message {
 public:
  OsmAndAddressNameIndexData();
  virtual ~OsmAndAddressNameIndexData();
  
  OsmAndAddressNameIndexData(const OsmAndAddressNameIndexData& from);
  
  inline OsmAndAddressNameIndexData& operator=(const OsmAndAddressNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressNameIndexData& default_instance();
  
  void Swap(OsmAndAddressNameIndexData* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndAddressNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressNameIndexData& from);
  void MergeFrom(const OsmAndAddressNameIndexData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OsmAndAddressNameIndexData_AddressNameIndexData AddressNameIndexData;
  
  // accessors -------------------------------------------------------
  
  // required .IndexedStringTable table = 4;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 4;
  inline const ::IndexedStringTable& table() const;
  inline ::IndexedStringTable* mutable_table();
  
  // repeated .OsmAndAddressNameIndexData.AddressNameIndexData atom = 7;
  inline int atom_size() const;
  inline void clear_atom();
  static const int kAtomFieldNumber = 7;
  inline const ::OsmAndAddressNameIndexData_AddressNameIndexData& atom(int index) const;
  inline ::OsmAndAddressNameIndexData_AddressNameIndexData* mutable_atom(int index);
  inline ::OsmAndAddressNameIndexData_AddressNameIndexData* add_atom();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndAddressNameIndexData_AddressNameIndexData >&
      atom() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndAddressNameIndexData_AddressNameIndexData >*
      mutable_atom();
  
  // @@protoc_insertion_point(class_scope:OsmAndAddressNameIndexData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::IndexedStringTable* table_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndAddressNameIndexData_AddressNameIndexData > atom_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndAddressNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class AddressNameIndexDataAtom : public ::google::protobuf::Message {
 public:
  AddressNameIndexDataAtom();
  virtual ~AddressNameIndexDataAtom();
  
  AddressNameIndexDataAtom(const AddressNameIndexDataAtom& from);
  
  inline AddressNameIndexDataAtom& operator=(const AddressNameIndexDataAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressNameIndexDataAtom& default_instance();
  
  void Swap(AddressNameIndexDataAtom* other);
  
  // implements Message ----------------------------------------------
  
  AddressNameIndexDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddressNameIndexDataAtom& from);
  void MergeFrom(const AddressNameIndexDataAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string nameEn = 2;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  
  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // repeated int32 shiftToIndex = 5;
  inline int shifttoindex_size() const;
  inline void clear_shifttoindex();
  static const int kShiftToIndexFieldNumber = 5;
  inline ::google::protobuf::int32 shifttoindex(int index) const;
  inline void set_shifttoindex(int index, ::google::protobuf::int32 value);
  inline void add_shifttoindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shifttoindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shifttoindex();
  
  // repeated int32 shiftToCityIndex = 6;
  inline int shifttocityindex_size() const;
  inline void clear_shifttocityindex();
  static const int kShiftToCityIndexFieldNumber = 6;
  inline ::google::protobuf::int32 shifttocityindex(int index) const;
  inline void set_shifttocityindex(int index, ::google::protobuf::int32 value);
  inline void add_shifttocityindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shifttocityindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shifttocityindex();
  
  // @@protoc_insertion_point(class_scope:AddressNameIndexDataAtom)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* nameen_;
  static const ::std::string _default_nameen_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shifttoindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shifttocityindex_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AddressNameIndexDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class CityIndex : public ::google::protobuf::Message {
 public:
  CityIndex();
  virtual ~CityIndex();
  
  CityIndex(const CityIndex& from);
  
  inline CityIndex& operator=(const CityIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CityIndex& default_instance();
  
  void Swap(CityIndex* other);
  
  // implements Message ----------------------------------------------
  
  CityIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CityIndex& from);
  void MergeFrom(const CityIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 city_type = 1;
  inline bool has_city_type() const;
  inline void clear_city_type();
  static const int kCityTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 city_type() const;
  inline void set_city_type(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 3;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 3;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional uint64 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // required uint32 x = 5;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 5;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // required uint32 y = 6;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 6;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // optional fixed32 shiftToCityBlockIndex = 10;
  inline bool has_shifttocityblockindex() const;
  inline void clear_shifttocityblockindex();
  static const int kShiftToCityBlockIndexFieldNumber = 10;
  inline ::google::protobuf::uint32 shifttocityblockindex() const;
  inline void set_shifttocityblockindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:CityIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 city_type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 shifttocityblockindex_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CityIndex* default_instance_;
};
// -------------------------------------------------------------------

class CityBlockIndex : public ::google::protobuf::Message {
 public:
  CityBlockIndex();
  virtual ~CityBlockIndex();
  
  CityBlockIndex(const CityBlockIndex& from);
  
  inline CityBlockIndex& operator=(const CityBlockIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CityBlockIndex& default_instance();
  
  void Swap(CityBlockIndex* other);
  
  // implements Message ----------------------------------------------
  
  CityBlockIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CityBlockIndex& from);
  void MergeFrom(const CityBlockIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional fixed32 shiftToCityIndex = 4;
  inline bool has_shifttocityindex() const;
  inline void clear_shifttocityindex();
  static const int kShiftToCityIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 shifttocityindex() const;
  inline void set_shifttocityindex(::google::protobuf::uint32 value);
  
  // repeated .BuildingIndex buildings = 10;
  inline int buildings_size() const;
  inline void clear_buildings();
  static const int kBuildingsFieldNumber = 10;
  inline const ::BuildingIndex& buildings(int index) const;
  inline ::BuildingIndex* mutable_buildings(int index);
  inline ::BuildingIndex* add_buildings();
  inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
      buildings() const;
  inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
      mutable_buildings();
  
  // repeated .StreetIndex streets = 12;
  inline int streets_size() const;
  inline void clear_streets();
  static const int kStreetsFieldNumber = 12;
  inline const ::StreetIndex& streets(int index) const;
  inline ::StreetIndex* mutable_streets(int index);
  inline ::StreetIndex* add_streets();
  inline const ::google::protobuf::RepeatedPtrField< ::StreetIndex >&
      streets() const;
  inline ::google::protobuf::RepeatedPtrField< ::StreetIndex >*
      mutable_streets();
  
  // @@protoc_insertion_point(class_scope:CityBlockIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 shifttocityindex_;
  ::google::protobuf::RepeatedPtrField< ::BuildingIndex > buildings_;
  ::google::protobuf::RepeatedPtrField< ::StreetIndex > streets_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CityBlockIndex* default_instance_;
};
// -------------------------------------------------------------------

class StreetIndex : public ::google::protobuf::Message {
 public:
  StreetIndex();
  virtual ~StreetIndex();
  
  StreetIndex(const StreetIndex& from);
  
  inline StreetIndex& operator=(const StreetIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetIndex& default_instance();
  
  void Swap(StreetIndex* other);
  
  // implements Message ----------------------------------------------
  
  StreetIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetIndex& from);
  void MergeFrom(const StreetIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // required sint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required sint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional uint64 id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // repeated .BuildingIndex buildings = 12;
  inline int buildings_size() const;
  inline void clear_buildings();
  static const int kBuildingsFieldNumber = 12;
  inline const ::BuildingIndex& buildings(int index) const;
  inline ::BuildingIndex* mutable_buildings(int index);
  inline ::BuildingIndex* add_buildings();
  inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
      buildings() const;
  inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
      mutable_buildings();
  
  // repeated .StreetIntersection intersections = 5;
  inline int intersections_size() const;
  inline void clear_intersections();
  static const int kIntersectionsFieldNumber = 5;
  inline const ::StreetIntersection& intersections(int index) const;
  inline ::StreetIntersection* mutable_intersections(int index);
  inline ::StreetIntersection* add_intersections();
  inline const ::google::protobuf::RepeatedPtrField< ::StreetIntersection >&
      intersections() const;
  inline ::google::protobuf::RepeatedPtrField< ::StreetIntersection >*
      mutable_intersections();
  
  // @@protoc_insertion_point(class_scope:StreetIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedPtrField< ::BuildingIndex > buildings_;
  ::google::protobuf::RepeatedPtrField< ::StreetIntersection > intersections_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StreetIndex* default_instance_;
};
// -------------------------------------------------------------------

class StreetIntersection : public ::google::protobuf::Message {
 public:
  StreetIntersection();
  virtual ~StreetIntersection();
  
  StreetIntersection(const StreetIntersection& from);
  
  inline StreetIntersection& operator=(const StreetIntersection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetIntersection& default_instance();
  
  void Swap(StreetIntersection* other);
  
  // implements Message ----------------------------------------------
  
  StreetIntersection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetIntersection& from);
  void MergeFrom(const StreetIntersection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 3;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 3;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // required sint32 intersectedX = 4;
  inline bool has_intersectedx() const;
  inline void clear_intersectedx();
  static const int kIntersectedXFieldNumber = 4;
  inline ::google::protobuf::int32 intersectedx() const;
  inline void set_intersectedx(::google::protobuf::int32 value);
  
  // required sint32 intersectedY = 5;
  inline bool has_intersectedy() const;
  inline void clear_intersectedy();
  static const int kIntersectedYFieldNumber = 5;
  inline ::google::protobuf::int32 intersectedy() const;
  inline void set_intersectedy(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:StreetIntersection)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::google::protobuf::int32 intersectedx_;
  ::google::protobuf::int32 intersectedy_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StreetIntersection* default_instance_;
};
// -------------------------------------------------------------------

class BuildingIndex : public ::google::protobuf::Message {
 public:
  BuildingIndex();
  virtual ~BuildingIndex();
  
  BuildingIndex(const BuildingIndex& from);
  
  inline BuildingIndex& operator=(const BuildingIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingIndex& default_instance();
  
  void Swap(BuildingIndex* other);
  
  // implements Message ----------------------------------------------
  
  BuildingIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingIndex& from);
  void MergeFrom(const BuildingIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  
  // optional string name2 = 3;
  inline bool has_name2() const;
  inline void clear_name2();
  static const int kName2FieldNumber = 3;
  inline const ::std::string& name2() const;
  inline void set_name2(const ::std::string& value);
  inline void set_name2(const char* value);
  inline void set_name2(const char* value, size_t size);
  inline ::std::string* mutable_name2();
  
  // optional string name_en2 = 4;
  inline bool has_name_en2() const;
  inline void clear_name_en2();
  static const int kNameEn2FieldNumber = 4;
  inline const ::std::string& name_en2() const;
  inline void set_name_en2(const ::std::string& value);
  inline void set_name_en2(const char* value);
  inline void set_name_en2(const char* value, size_t size);
  inline ::std::string* mutable_name_en2();
  
  // optional sint32 interpolation = 5;
  inline bool has_interpolation() const;
  inline void clear_interpolation();
  static const int kInterpolationFieldNumber = 5;
  inline ::google::protobuf::int32 interpolation() const;
  inline void set_interpolation(::google::protobuf::int32 value);
  
  // required sint32 x = 7;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 7;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);
  
  // required sint32 y = 8;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 8;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);
  
  // optional sint32 x2 = 9;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 9;
  inline ::google::protobuf::int32 x2() const;
  inline void set_x2(::google::protobuf::int32 value);
  
  // optional sint32 y2 = 10;
  inline bool has_y2() const;
  inline void clear_y2();
  static const int kY2FieldNumber = 10;
  inline ::google::protobuf::int32 y2() const;
  inline void set_y2(::google::protobuf::int32 value);
  
  // optional uint64 id = 13;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 13;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional string postcode = 14;
  inline bool has_postcode() const;
  inline void clear_postcode();
  static const int kPostcodeFieldNumber = 14;
  inline const ::std::string& postcode() const;
  inline void set_postcode(const ::std::string& value);
  inline void set_postcode(const char* value);
  inline void set_postcode(const char* value, size_t size);
  inline ::std::string* mutable_postcode();
  
  // @@protoc_insertion_point(class_scope:BuildingIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* name_en_;
  static const ::std::string _default_name_en_;
  ::std::string* name2_;
  static const ::std::string _default_name2_;
  ::std::string* name_en2_;
  static const ::std::string _default_name_en2_;
  ::google::protobuf::int32 interpolation_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 x2_;
  ::google::protobuf::int32 y2_;
  ::google::protobuf::uint64 id_;
  ::std::string* postcode_;
  static const ::std::string _default_postcode_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BuildingIndex* default_instance_;
};
// -------------------------------------------------------------------

class TransportRoutes : public ::google::protobuf::Message {
 public:
  TransportRoutes();
  virtual ~TransportRoutes();
  
  TransportRoutes(const TransportRoutes& from);
  
  inline TransportRoutes& operator=(const TransportRoutes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRoutes& default_instance();
  
  void Swap(TransportRoutes* other);
  
  // implements Message ----------------------------------------------
  
  TransportRoutes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRoutes& from);
  void MergeFrom(const TransportRoutes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .TransportRoute routes = 6;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 6;
  inline const ::TransportRoute& routes(int index) const;
  inline ::TransportRoute* mutable_routes(int index);
  inline ::TransportRoute* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRoute >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRoute >*
      mutable_routes();
  
  // @@protoc_insertion_point(class_scope:TransportRoutes)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::TransportRoute > routes_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRoutes* default_instance_;
};
// -------------------------------------------------------------------

class TransportRoute : public ::google::protobuf::Message {
 public:
  TransportRoute();
  virtual ~TransportRoute();
  
  TransportRoute(const TransportRoute& from);
  
  inline TransportRoute& operator=(const TransportRoute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRoute& default_instance();
  
  void Swap(TransportRoute* other);
  
  // implements Message ----------------------------------------------
  
  TransportRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRoute& from);
  void MergeFrom(const TransportRoute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint32 operator = 4;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 4;
  inline ::google::protobuf::uint32 operator_() const;
  inline void set_operator_(::google::protobuf::uint32 value);
  
  // optional string ref = 5;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 5;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  
  // optional uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // optional uint32 distance = 8;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 8;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);
  
  // repeated .TransportRouteStop directStops = 15;
  inline int directstops_size() const;
  inline void clear_directstops();
  static const int kDirectStopsFieldNumber = 15;
  inline const ::TransportRouteStop& directstops(int index) const;
  inline ::TransportRouteStop* mutable_directstops(int index);
  inline ::TransportRouteStop* add_directstops();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
      directstops() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
      mutable_directstops();
  
  // repeated .TransportRouteStop reverseStops = 16;
  inline int reversestops_size() const;
  inline void clear_reversestops();
  static const int kReverseStopsFieldNumber = 16;
  inline const ::TransportRouteStop& reversestops(int index) const;
  inline ::TransportRouteStop* mutable_reversestops(int index);
  inline ::TransportRouteStop* add_reversestops();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
      reversestops() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
      mutable_reversestops();
  
  // @@protoc_insertion_point(class_scope:TransportRoute)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 operator__;
  ::std::string* ref_;
  static const ::std::string _default_ref_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  ::google::protobuf::uint32 distance_;
  ::google::protobuf::RepeatedPtrField< ::TransportRouteStop > directstops_;
  ::google::protobuf::RepeatedPtrField< ::TransportRouteStop > reversestops_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRoute* default_instance_;
};
// -------------------------------------------------------------------

class TransportRouteStop : public ::google::protobuf::Message {
 public:
  TransportRouteStop();
  virtual ~TransportRouteStop();
  
  TransportRouteStop(const TransportRouteStop& from);
  
  inline TransportRouteStop& operator=(const TransportRouteStop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRouteStop& default_instance();
  
  void Swap(TransportRouteStop* other);
  
  // implements Message ----------------------------------------------
  
  TransportRouteStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRouteStop& from);
  void MergeFrom(const TransportRouteStop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // required uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:TransportRouteStop)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportRouteStop* default_instance_;
};
// -------------------------------------------------------------------

class TransportStop : public ::google::protobuf::Message {
 public:
  TransportStop();
  virtual ~TransportStop();
  
  TransportStop(const TransportStop& from);
  
  inline TransportStop& operator=(const TransportStop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStop& default_instance();
  
  void Swap(TransportStop* other);
  
  // implements Message ----------------------------------------------
  
  TransportStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStop& from);
  void MergeFrom(const TransportStop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 dx = 1;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 1;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 2;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 2;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // required sint64 id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // required uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);
  
  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);
  
  // repeated uint32 routes = 16;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 16;
  inline ::google::protobuf::uint32 routes(int index) const;
  inline void set_routes(int index, ::google::protobuf::uint32 value);
  inline void add_routes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      routes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_routes();
  
  // @@protoc_insertion_point(class_scope:TransportStop)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > routes_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportStop* default_instance_;
};
// -------------------------------------------------------------------

class TransportStopsTree : public ::google::protobuf::Message {
 public:
  TransportStopsTree();
  virtual ~TransportStopsTree();
  
  TransportStopsTree(const TransportStopsTree& from);
  
  inline TransportStopsTree& operator=(const TransportStopsTree& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStopsTree& default_instance();
  
  void Swap(TransportStopsTree* other);
  
  // implements Message ----------------------------------------------
  
  TransportStopsTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStopsTree& from);
  void MergeFrom(const TransportStopsTree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);
  
  // repeated .TransportStopsTree subtrees = 7;
  inline int subtrees_size() const;
  inline void clear_subtrees();
  static const int kSubtreesFieldNumber = 7;
  inline const ::TransportStopsTree& subtrees(int index) const;
  inline ::TransportStopsTree* mutable_subtrees(int index);
  inline ::TransportStopsTree* add_subtrees();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >&
      subtrees() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >*
      mutable_subtrees();
  
  // repeated .TransportStop leafs = 8;
  inline int leafs_size() const;
  inline void clear_leafs();
  static const int kLeafsFieldNumber = 8;
  inline const ::TransportStop& leafs(int index) const;
  inline ::TransportStop* mutable_leafs(int index);
  inline ::TransportStop* add_leafs();
  inline const ::google::protobuf::RepeatedPtrField< ::TransportStop >&
      leafs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransportStop >*
      mutable_leafs();
  
  // optional uint64 baseId = 16;
  inline bool has_baseid() const;
  inline void clear_baseid();
  static const int kBaseIdFieldNumber = 16;
  inline ::google::protobuf::uint64 baseid() const;
  inline void set_baseid(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:TransportStopsTree)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::TransportStopsTree > subtrees_;
  ::google::protobuf::RepeatedPtrField< ::TransportStop > leafs_;
  ::google::protobuf::uint64 baseid_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransportStopsTree* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndTransportIndex : public ::google::protobuf::Message {
 public:
  OsmAndTransportIndex();
  virtual ~OsmAndTransportIndex();
  
  OsmAndTransportIndex(const OsmAndTransportIndex& from);
  
  inline OsmAndTransportIndex& operator=(const OsmAndTransportIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndTransportIndex& default_instance();
  
  void Swap(OsmAndTransportIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndTransportIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndTransportIndex& from);
  void MergeFrom(const OsmAndTransportIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional .TransportRoutes routes = 3;
  inline bool has_routes() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 3;
  inline const ::TransportRoutes& routes() const;
  inline ::TransportRoutes* mutable_routes();
  
  // optional .TransportStopsTree stops = 6;
  inline bool has_stops() const;
  inline void clear_stops();
  static const int kStopsFieldNumber = 6;
  inline const ::TransportStopsTree& stops() const;
  inline ::TransportStopsTree* mutable_stops();
  
  // required .StringTable stringTable = 9;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 9;
  inline const ::StringTable& stringtable() const;
  inline ::StringTable* mutable_stringtable();
  
  // @@protoc_insertion_point(class_scope:OsmAndTransportIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::TransportRoutes* routes_;
  ::TransportStopsTree* stops_;
  ::StringTable* stringtable_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndTransportIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiIndex : public ::google::protobuf::Message {
 public:
  OsmAndPoiIndex();
  virtual ~OsmAndPoiIndex();
  
  OsmAndPoiIndex(const OsmAndPoiIndex& from);
  
  inline OsmAndPoiIndex& operator=(const OsmAndPoiIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiIndex& default_instance();
  
  void Swap(OsmAndPoiIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiIndex& from);
  void MergeFrom(const OsmAndPoiIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .OsmAndTileBox boundaries = 2;
  inline bool has_boundaries() const;
  inline void clear_boundaries();
  static const int kBoundariesFieldNumber = 2;
  inline const ::OsmAndTileBox& boundaries() const;
  inline ::OsmAndTileBox* mutable_boundaries();
  
  // repeated .OsmAndCategoryTable categoriesTable = 3;
  inline int categoriestable_size() const;
  inline void clear_categoriestable();
  static const int kCategoriesTableFieldNumber = 3;
  inline const ::OsmAndCategoryTable& categoriestable(int index) const;
  inline ::OsmAndCategoryTable* mutable_categoriestable(int index);
  inline ::OsmAndCategoryTable* add_categoriestable();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable >&
      categoriestable() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable >*
      mutable_categoriestable();
  
  // optional .OsmAndPoiNameIndex nameIndex = 4;
  inline bool has_nameindex() const;
  inline void clear_nameindex();
  static const int kNameIndexFieldNumber = 4;
  inline const ::OsmAndPoiNameIndex& nameindex() const;
  inline ::OsmAndPoiNameIndex* mutable_nameindex();
  
  // repeated .OsmAndPoiBox boxes = 6;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 6;
  inline const ::OsmAndPoiBox& boxes(int index) const;
  inline ::OsmAndPoiBox* mutable_boxes(int index);
  inline ::OsmAndPoiBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >*
      mutable_boxes();
  
  // repeated .OsmAndPoiBoxData poiData = 9;
  inline int poidata_size() const;
  inline void clear_poidata();
  static const int kPoiDataFieldNumber = 9;
  inline const ::OsmAndPoiBoxData& poidata(int index) const;
  inline ::OsmAndPoiBoxData* mutable_poidata(int index);
  inline ::OsmAndPoiBoxData* add_poidata();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData >&
      poidata() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData >*
      mutable_poidata();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::OsmAndTileBox* boundaries_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable > categoriestable_;
  ::OsmAndPoiNameIndex* nameindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData > poidata_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndex_OsmAndPoiNameIndexData : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndex_OsmAndPoiNameIndexData();
  virtual ~OsmAndPoiNameIndex_OsmAndPoiNameIndexData();
  
  OsmAndPoiNameIndex_OsmAndPoiNameIndexData(const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& from);
  
  inline OsmAndPoiNameIndex_OsmAndPoiNameIndexData& operator=(const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& default_instance();
  
  void Swap(OsmAndPoiNameIndex_OsmAndPoiNameIndexData* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiNameIndex_OsmAndPoiNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& from);
  void MergeFrom(const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .OsmAndPoiNameIndexDataAtom atoms = 3;
  inline int atoms_size() const;
  inline void clear_atoms();
  static const int kAtomsFieldNumber = 3;
  inline const ::OsmAndPoiNameIndexDataAtom& atoms(int index) const;
  inline ::OsmAndPoiNameIndexDataAtom* mutable_atoms(int index);
  inline ::OsmAndPoiNameIndexDataAtom* add_atoms();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom >&
      atoms() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom >*
      mutable_atoms();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiNameIndex.OsmAndPoiNameIndexData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom > atoms_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiNameIndex_OsmAndPoiNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndex : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndex();
  virtual ~OsmAndPoiNameIndex();
  
  OsmAndPoiNameIndex(const OsmAndPoiNameIndex& from);
  
  inline OsmAndPoiNameIndex& operator=(const OsmAndPoiNameIndex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndex& default_instance();
  
  void Swap(OsmAndPoiNameIndex* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiNameIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndex& from);
  void MergeFrom(const OsmAndPoiNameIndex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OsmAndPoiNameIndex_OsmAndPoiNameIndexData OsmAndPoiNameIndexData;
  
  // accessors -------------------------------------------------------
  
  // required .IndexedStringTable table = 3;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 3;
  inline const ::IndexedStringTable& table() const;
  inline ::IndexedStringTable* mutable_table();
  
  // repeated .OsmAndPoiNameIndex.OsmAndPoiNameIndexData data = 5;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData& data(int index) const;
  inline ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData* mutable_data(int index);
  inline ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiNameIndex)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::IndexedStringTable* table_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData > data_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiNameIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndexDataAtom : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndexDataAtom();
  virtual ~OsmAndPoiNameIndexDataAtom();
  
  OsmAndPoiNameIndexDataAtom(const OsmAndPoiNameIndexDataAtom& from);
  
  inline OsmAndPoiNameIndexDataAtom& operator=(const OsmAndPoiNameIndexDataAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndexDataAtom& default_instance();
  
  void Swap(OsmAndPoiNameIndexDataAtom* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiNameIndexDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndexDataAtom& from);
  void MergeFrom(const OsmAndPoiNameIndexDataAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 zoom = 2;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 2;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // optional uint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // optional uint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // optional fixed32 shiftTo = 14;
  inline bool has_shiftto() const;
  inline void clear_shiftto();
  static const int kShiftToFieldNumber = 14;
  inline ::google::protobuf::uint32 shiftto() const;
  inline void set_shiftto(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiNameIndexDataAtom)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 shiftto_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiNameIndexDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndCategoryTable : public ::google::protobuf::Message {
 public:
  OsmAndCategoryTable();
  virtual ~OsmAndCategoryTable();
  
  OsmAndCategoryTable(const OsmAndCategoryTable& from);
  
  inline OsmAndCategoryTable& operator=(const OsmAndCategoryTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndCategoryTable& default_instance();
  
  void Swap(OsmAndCategoryTable* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndCategoryTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndCategoryTable& from);
  void MergeFrom(const OsmAndCategoryTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string category = 1;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  
  // repeated string subcategories = 3;
  inline int subcategories_size() const;
  inline void clear_subcategories();
  static const int kSubcategoriesFieldNumber = 3;
  inline const ::std::string& subcategories(int index) const;
  inline ::std::string* mutable_subcategories(int index);
  inline void set_subcategories(int index, const ::std::string& value);
  inline void set_subcategories(int index, const char* value);
  inline void set_subcategories(int index, const char* value, size_t size);
  inline ::std::string* add_subcategories();
  inline void add_subcategories(const ::std::string& value);
  inline void add_subcategories(const char* value);
  inline void add_subcategories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& subcategories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subcategories();
  
  // @@protoc_insertion_point(class_scope:OsmAndCategoryTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* category_;
  static const ::std::string _default_category_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subcategories_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndCategoryTable* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBox : public ::google::protobuf::Message {
 public:
  OsmAndPoiBox();
  virtual ~OsmAndPoiBox();
  
  OsmAndPoiBox(const OsmAndPoiBox& from);
  
  inline OsmAndPoiBox& operator=(const OsmAndPoiBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBox& default_instance();
  
  void Swap(OsmAndPoiBox* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBox& from);
  void MergeFrom(const OsmAndPoiBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 zoom = 1;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 1;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // required sint32 left = 2;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 2;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);
  
  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);
  
  // optional .OsmAndPoiCategories categories = 4;
  inline bool has_categories() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline const ::OsmAndPoiCategories& categories() const;
  inline ::OsmAndPoiCategories* mutable_categories();
  
  // repeated .OsmAndPoiBox subBoxes = 10;
  inline int subboxes_size() const;
  inline void clear_subboxes();
  static const int kSubBoxesFieldNumber = 10;
  inline const ::OsmAndPoiBox& subboxes(int index) const;
  inline ::OsmAndPoiBox* mutable_subboxes(int index);
  inline ::OsmAndPoiBox* add_subboxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >&
      subboxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >*
      mutable_subboxes();
  
  // optional fixed32 shiftToData = 14;
  inline bool has_shifttodata() const;
  inline void clear_shifttodata();
  static const int kShiftToDataFieldNumber = 14;
  inline ::google::protobuf::uint32 shifttodata() const;
  inline void set_shifttodata(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiBox)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 top_;
  ::OsmAndPoiCategories* categories_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox > subboxes_;
  ::google::protobuf::uint32 shifttodata_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiBox* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiCategories : public ::google::protobuf::Message {
 public:
  OsmAndPoiCategories();
  virtual ~OsmAndPoiCategories();
  
  OsmAndPoiCategories(const OsmAndPoiCategories& from);
  
  inline OsmAndPoiCategories& operator=(const OsmAndPoiCategories& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiCategories& default_instance();
  
  void Swap(OsmAndPoiCategories* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiCategories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiCategories& from);
  void MergeFrom(const OsmAndPoiCategories& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 categories = 3;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 3;
  inline ::google::protobuf::uint32 categories(int index) const;
  inline void set_categories(int index, ::google::protobuf::uint32 value);
  inline void add_categories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      categories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_categories();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiCategories)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > categories_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiCategories* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBoxData : public ::google::protobuf::Message {
 public:
  OsmAndPoiBoxData();
  virtual ~OsmAndPoiBoxData();
  
  OsmAndPoiBoxData(const OsmAndPoiBoxData& from);
  
  inline OsmAndPoiBoxData& operator=(const OsmAndPoiBoxData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBoxData& default_instance();
  
  void Swap(OsmAndPoiBoxData* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiBoxData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBoxData& from);
  void MergeFrom(const OsmAndPoiBoxData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 zoom = 1;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 1;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);
  
  // optional uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);
  
  // optional uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);
  
  // repeated .OsmAndPoiBoxDataAtom poiData = 5;
  inline int poidata_size() const;
  inline void clear_poidata();
  static const int kPoiDataFieldNumber = 5;
  inline const ::OsmAndPoiBoxDataAtom& poidata(int index) const;
  inline ::OsmAndPoiBoxDataAtom* mutable_poidata(int index);
  inline ::OsmAndPoiBoxDataAtom* add_poidata();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom >&
      poidata() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom >*
      mutable_poidata();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiBoxData)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom > poidata_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiBoxData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBoxDataAtom : public ::google::protobuf::Message {
 public:
  OsmAndPoiBoxDataAtom();
  virtual ~OsmAndPoiBoxDataAtom();
  
  OsmAndPoiBoxDataAtom(const OsmAndPoiBoxDataAtom& from);
  
  inline OsmAndPoiBoxDataAtom& operator=(const OsmAndPoiBoxDataAtom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBoxDataAtom& default_instance();
  
  void Swap(OsmAndPoiBoxDataAtom* other);
  
  // implements Message ----------------------------------------------
  
  OsmAndPoiBoxDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBoxDataAtom& from);
  void MergeFrom(const OsmAndPoiBoxDataAtom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);
  
  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);
  
  // repeated uint32 categories = 4;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline ::google::protobuf::uint32 categories(int index) const;
  inline void set_categories(int index, ::google::protobuf::uint32 value);
  inline void add_categories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      categories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_categories();
  
  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string nameEn = 7;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameEnFieldNumber = 7;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  
  // optional uint64 id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
  // optional string openingHours = 10;
  inline bool has_openinghours() const;
  inline void clear_openinghours();
  static const int kOpeningHoursFieldNumber = 10;
  inline const ::std::string& openinghours() const;
  inline void set_openinghours(const ::std::string& value);
  inline void set_openinghours(const char* value);
  inline void set_openinghours(const char* value, size_t size);
  inline ::std::string* mutable_openinghours();
  
  // optional string site = 11;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 11;
  inline const ::std::string& site() const;
  inline void set_site(const ::std::string& value);
  inline void set_site(const char* value);
  inline void set_site(const char* value, size_t size);
  inline ::std::string* mutable_site();
  
  // optional string phone = 12;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 12;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  
  // optional string note = 13;
  inline bool has_note() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 13;
  inline const ::std::string& note() const;
  inline void set_note(const ::std::string& value);
  inline void set_note(const char* value);
  inline void set_note(const char* value, size_t size);
  inline ::std::string* mutable_note();
  
  // @@protoc_insertion_point(class_scope:OsmAndPoiBoxDataAtom)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > categories_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* nameen_;
  static const ::std::string _default_nameen_;
  ::google::protobuf::uint64 id_;
  ::std::string* openinghours_;
  static const ::std::string _default_openinghours_;
  ::std::string* site_;
  static const ::std::string _default_site_;
  ::std::string* phone_;
  static const ::std::string _default_phone_;
  ::std::string* note_;
  static const ::std::string _default_note_;
  friend void  protobuf_AddDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_AssignDesc_src_2fosmand_5fodb_2eproto();
  friend void protobuf_ShutdownFile_src_2fosmand_5fodb_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OsmAndPoiBoxDataAtom* default_instance_;
};
// ===================================================================


// ===================================================================

// OsmAndStructure

// required uint32 version = 1;
inline bool OsmAndStructure::has_version() const {
  return _has_bit(0);
}
inline void OsmAndStructure::clear_version() {
  version_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndStructure::version() const {
  return version_;
}
inline void OsmAndStructure::set_version(::google::protobuf::uint32 value) {
  _set_bit(0);
  version_ = value;
}

// required int64 dateCreated = 18;
inline bool OsmAndStructure::has_datecreated() const {
  return _has_bit(1);
}
inline void OsmAndStructure::clear_datecreated() {
  datecreated_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 OsmAndStructure::datecreated() const {
  return datecreated_;
}
inline void OsmAndStructure::set_datecreated(::google::protobuf::int64 value) {
  _set_bit(1);
  datecreated_ = value;
}

// repeated .OsmAndAddressIndex addressIndex = 7;
inline int OsmAndStructure::addressindex_size() const {
  return addressindex_.size();
}
inline void OsmAndStructure::clear_addressindex() {
  addressindex_.Clear();
}
inline const ::OsmAndAddressIndex& OsmAndStructure::addressindex(int index) const {
  return addressindex_.Get(index);
}
inline ::OsmAndAddressIndex* OsmAndStructure::mutable_addressindex(int index) {
  return addressindex_.Mutable(index);
}
inline ::OsmAndAddressIndex* OsmAndStructure::add_addressindex() {
  return addressindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex >&
OsmAndStructure::addressindex() const {
  return addressindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex >*
OsmAndStructure::mutable_addressindex() {
  return &addressindex_;
}

// repeated .OsmAndTransportIndex transportIndex = 4;
inline int OsmAndStructure::transportindex_size() const {
  return transportindex_.size();
}
inline void OsmAndStructure::clear_transportindex() {
  transportindex_.Clear();
}
inline const ::OsmAndTransportIndex& OsmAndStructure::transportindex(int index) const {
  return transportindex_.Get(index);
}
inline ::OsmAndTransportIndex* OsmAndStructure::mutable_transportindex(int index) {
  return transportindex_.Mutable(index);
}
inline ::OsmAndTransportIndex* OsmAndStructure::add_transportindex() {
  return transportindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex >&
OsmAndStructure::transportindex() const {
  return transportindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndTransportIndex >*
OsmAndStructure::mutable_transportindex() {
  return &transportindex_;
}

// repeated .OsmAndPoiIndex poiIndex = 8;
inline int OsmAndStructure::poiindex_size() const {
  return poiindex_.size();
}
inline void OsmAndStructure::clear_poiindex() {
  poiindex_.Clear();
}
inline const ::OsmAndPoiIndex& OsmAndStructure::poiindex(int index) const {
  return poiindex_.Get(index);
}
inline ::OsmAndPoiIndex* OsmAndStructure::mutable_poiindex(int index) {
  return poiindex_.Mutable(index);
}
inline ::OsmAndPoiIndex* OsmAndStructure::add_poiindex() {
  return poiindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex >&
OsmAndStructure::poiindex() const {
  return poiindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiIndex >*
OsmAndStructure::mutable_poiindex() {
  return &poiindex_;
}

// repeated .OsmAndMapIndex mapIndex = 6;
inline int OsmAndStructure::mapindex_size() const {
  return mapindex_.size();
}
inline void OsmAndStructure::clear_mapindex() {
  mapindex_.Clear();
}
inline const ::OsmAndMapIndex& OsmAndStructure::mapindex(int index) const {
  return mapindex_.Get(index);
}
inline ::OsmAndMapIndex* OsmAndStructure::mutable_mapindex(int index) {
  return mapindex_.Mutable(index);
}
inline ::OsmAndMapIndex* OsmAndStructure::add_mapindex() {
  return mapindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex >&
OsmAndStructure::mapindex() const {
  return mapindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex >*
OsmAndStructure::mutable_mapindex() {
  return &mapindex_;
}

// required uint32 versionConfirm = 32;
inline bool OsmAndStructure::has_versionconfirm() const {
  return _has_bit(6);
}
inline void OsmAndStructure::clear_versionconfirm() {
  versionconfirm_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 OsmAndStructure::versionconfirm() const {
  return versionconfirm_;
}
inline void OsmAndStructure::set_versionconfirm(::google::protobuf::uint32 value) {
  _set_bit(6);
  versionconfirm_ = value;
}

// -------------------------------------------------------------------

// OsmAndTileBox

// required uint32 left = 1;
inline bool OsmAndTileBox::has_left() const {
  return _has_bit(0);
}
inline void OsmAndTileBox::clear_left() {
  left_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndTileBox::left() const {
  return left_;
}
inline void OsmAndTileBox::set_left(::google::protobuf::uint32 value) {
  _set_bit(0);
  left_ = value;
}

// required uint32 right = 2;
inline bool OsmAndTileBox::has_right() const {
  return _has_bit(1);
}
inline void OsmAndTileBox::clear_right() {
  right_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 OsmAndTileBox::right() const {
  return right_;
}
inline void OsmAndTileBox::set_right(::google::protobuf::uint32 value) {
  _set_bit(1);
  right_ = value;
}

// required uint32 top = 3;
inline bool OsmAndTileBox::has_top() const {
  return _has_bit(2);
}
inline void OsmAndTileBox::clear_top() {
  top_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 OsmAndTileBox::top() const {
  return top_;
}
inline void OsmAndTileBox::set_top(::google::protobuf::uint32 value) {
  _set_bit(2);
  top_ = value;
}

// required uint32 bottom = 4;
inline bool OsmAndTileBox::has_bottom() const {
  return _has_bit(3);
}
inline void OsmAndTileBox::clear_bottom() {
  bottom_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 OsmAndTileBox::bottom() const {
  return bottom_;
}
inline void OsmAndTileBox::set_bottom(::google::protobuf::uint32 value) {
  _set_bit(3);
  bottom_ = value;
}

// -------------------------------------------------------------------

// StringTable

// repeated string s = 1;
inline int StringTable::s_size() const {
  return s_.size();
}
inline void StringTable::clear_s() {
  s_.Clear();
}
inline const ::std::string& StringTable::s(int index) const {
  return s_.Get(index);
}
inline ::std::string* StringTable::mutable_s(int index) {
  return s_.Mutable(index);
}
inline void StringTable::set_s(int index, const ::std::string& value) {
  s_.Mutable(index)->assign(value);
}
inline void StringTable::set_s(int index, const char* value) {
  s_.Mutable(index)->assign(value);
}
inline void StringTable::set_s(int index, const char* value, size_t size) {
  s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringTable::add_s() {
  return s_.Add();
}
inline void StringTable::add_s(const ::std::string& value) {
  s_.Add()->assign(value);
}
inline void StringTable::add_s(const char* value) {
  s_.Add()->assign(value);
}
inline void StringTable::add_s(const char* value, size_t size) {
  s_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringTable::s() const {
  return s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringTable::mutable_s() {
  return &s_;
}

// -------------------------------------------------------------------

// IndexedStringTable

// optional string prefix = 1;
inline bool IndexedStringTable::has_prefix() const {
  return _has_bit(0);
}
inline void IndexedStringTable::clear_prefix() {
  if (prefix_ != &_default_prefix_) {
    prefix_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IndexedStringTable::prefix() const {
  return *prefix_;
}
inline void IndexedStringTable::set_prefix(const ::std::string& value) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void IndexedStringTable::set_prefix(const char* value) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void IndexedStringTable::set_prefix(const char* value, size_t size) {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IndexedStringTable::mutable_prefix() {
  _set_bit(0);
  if (prefix_ == &_default_prefix_) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}

// repeated string key = 3;
inline int IndexedStringTable::key_size() const {
  return key_.size();
}
inline void IndexedStringTable::clear_key() {
  key_.Clear();
}
inline const ::std::string& IndexedStringTable::key(int index) const {
  return key_.Get(index);
}
inline ::std::string* IndexedStringTable::mutable_key(int index) {
  return key_.Mutable(index);
}
inline void IndexedStringTable::set_key(int index, const ::std::string& value) {
  key_.Mutable(index)->assign(value);
}
inline void IndexedStringTable::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
}
inline void IndexedStringTable::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IndexedStringTable::add_key() {
  return key_.Add();
}
inline void IndexedStringTable::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
}
inline void IndexedStringTable::add_key(const char* value) {
  key_.Add()->assign(value);
}
inline void IndexedStringTable::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexedStringTable::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexedStringTable::mutable_key() {
  return &key_;
}

// repeated fixed32 val = 4;
inline int IndexedStringTable::val_size() const {
  return val_.size();
}
inline void IndexedStringTable::clear_val() {
  val_.Clear();
}
inline ::google::protobuf::uint32 IndexedStringTable::val(int index) const {
  return val_.Get(index);
}
inline void IndexedStringTable::set_val(int index, ::google::protobuf::uint32 value) {
  val_.Set(index, value);
}
inline void IndexedStringTable::add_val(::google::protobuf::uint32 value) {
  val_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IndexedStringTable::val() const {
  return val_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IndexedStringTable::mutable_val() {
  return &val_;
}

// repeated .IndexedStringTable subtables = 5;
inline int IndexedStringTable::subtables_size() const {
  return subtables_.size();
}
inline void IndexedStringTable::clear_subtables() {
  subtables_.Clear();
}
inline const ::IndexedStringTable& IndexedStringTable::subtables(int index) const {
  return subtables_.Get(index);
}
inline ::IndexedStringTable* IndexedStringTable::mutable_subtables(int index) {
  return subtables_.Mutable(index);
}
inline ::IndexedStringTable* IndexedStringTable::add_subtables() {
  return subtables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >&
IndexedStringTable::subtables() const {
  return subtables_;
}
inline ::google::protobuf::RepeatedPtrField< ::IndexedStringTable >*
IndexedStringTable::mutable_subtables() {
  return &subtables_;
}

// -------------------------------------------------------------------

// OsmAndMapIndex_MapEncodingRule

// required string tag = 3;
inline bool OsmAndMapIndex_MapEncodingRule::has_tag() const {
  return _has_bit(0);
}
inline void OsmAndMapIndex_MapEncodingRule::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndMapIndex_MapEncodingRule::tag() const {
  return *tag_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_tag(const ::std::string& value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void OsmAndMapIndex_MapEncodingRule::set_tag(const char* value) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void OsmAndMapIndex_MapEncodingRule::set_tag(const char* value, size_t size) {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndMapIndex_MapEncodingRule::mutable_tag() {
  _set_bit(0);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// optional string value = 5;
inline bool OsmAndMapIndex_MapEncodingRule::has_value() const {
  return _has_bit(1);
}
inline void OsmAndMapIndex_MapEncodingRule::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OsmAndMapIndex_MapEncodingRule::value() const {
  return *value_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OsmAndMapIndex_MapEncodingRule::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OsmAndMapIndex_MapEncodingRule::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndMapIndex_MapEncodingRule::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional uint32 id = 7;
inline bool OsmAndMapIndex_MapEncodingRule::has_id() const {
  return _has_bit(2);
}
inline void OsmAndMapIndex_MapEncodingRule::clear_id() {
  id_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 OsmAndMapIndex_MapEncodingRule::id() const {
  return id_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_id(::google::protobuf::uint32 value) {
  _set_bit(2);
  id_ = value;
}

// optional uint32 minZoom = 9;
inline bool OsmAndMapIndex_MapEncodingRule::has_minzoom() const {
  return _has_bit(3);
}
inline void OsmAndMapIndex_MapEncodingRule::clear_minzoom() {
  minzoom_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 OsmAndMapIndex_MapEncodingRule::minzoom() const {
  return minzoom_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_minzoom(::google::protobuf::uint32 value) {
  _set_bit(3);
  minzoom_ = value;
}

// optional uint32 type = 10;
inline bool OsmAndMapIndex_MapEncodingRule::has_type() const {
  return _has_bit(4);
}
inline void OsmAndMapIndex_MapEncodingRule::clear_type() {
  type_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 OsmAndMapIndex_MapEncodingRule::type() const {
  return type_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_type(::google::protobuf::uint32 value) {
  _set_bit(4);
  type_ = value;
}

// -------------------------------------------------------------------

// OsmAndMapIndex_MapRootLevel

// required int32 maxZoom = 1;
inline bool OsmAndMapIndex_MapRootLevel::has_maxzoom() const {
  return _has_bit(0);
}
inline void OsmAndMapIndex_MapRootLevel::clear_maxzoom() {
  maxzoom_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::maxzoom() const {
  return maxzoom_;
}
inline void OsmAndMapIndex_MapRootLevel::set_maxzoom(::google::protobuf::int32 value) {
  _set_bit(0);
  maxzoom_ = value;
}

// required int32 minZoom = 2;
inline bool OsmAndMapIndex_MapRootLevel::has_minzoom() const {
  return _has_bit(1);
}
inline void OsmAndMapIndex_MapRootLevel::clear_minzoom() {
  minzoom_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::minzoom() const {
  return minzoom_;
}
inline void OsmAndMapIndex_MapRootLevel::set_minzoom(::google::protobuf::int32 value) {
  _set_bit(1);
  minzoom_ = value;
}

// required int32 left = 3;
inline bool OsmAndMapIndex_MapRootLevel::has_left() const {
  return _has_bit(2);
}
inline void OsmAndMapIndex_MapRootLevel::clear_left() {
  left_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::left() const {
  return left_;
}
inline void OsmAndMapIndex_MapRootLevel::set_left(::google::protobuf::int32 value) {
  _set_bit(2);
  left_ = value;
}

// required int32 right = 4;
inline bool OsmAndMapIndex_MapRootLevel::has_right() const {
  return _has_bit(3);
}
inline void OsmAndMapIndex_MapRootLevel::clear_right() {
  right_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::right() const {
  return right_;
}
inline void OsmAndMapIndex_MapRootLevel::set_right(::google::protobuf::int32 value) {
  _set_bit(3);
  right_ = value;
}

// required int32 top = 5;
inline bool OsmAndMapIndex_MapRootLevel::has_top() const {
  return _has_bit(4);
}
inline void OsmAndMapIndex_MapRootLevel::clear_top() {
  top_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::top() const {
  return top_;
}
inline void OsmAndMapIndex_MapRootLevel::set_top(::google::protobuf::int32 value) {
  _set_bit(4);
  top_ = value;
}

// required int32 bottom = 6;
inline bool OsmAndMapIndex_MapRootLevel::has_bottom() const {
  return _has_bit(5);
}
inline void OsmAndMapIndex_MapRootLevel::clear_bottom() {
  bottom_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::bottom() const {
  return bottom_;
}
inline void OsmAndMapIndex_MapRootLevel::set_bottom(::google::protobuf::int32 value) {
  _set_bit(5);
  bottom_ = value;
}

// repeated .OsmAndMapIndex.MapDataBox boxes = 7;
inline int OsmAndMapIndex_MapRootLevel::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndMapIndex_MapRootLevel::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAndMapIndex_MapDataBox& OsmAndMapIndex_MapRootLevel::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAndMapIndex_MapDataBox* OsmAndMapIndex_MapRootLevel::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAndMapIndex_MapDataBox* OsmAndMapIndex_MapRootLevel::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox >&
OsmAndMapIndex_MapRootLevel::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox >*
OsmAndMapIndex_MapRootLevel::mutable_boxes() {
  return &boxes_;
}

// repeated .MapDataBlock blocks = 15;
inline int OsmAndMapIndex_MapRootLevel::blocks_size() const {
  return blocks_.size();
}
inline void OsmAndMapIndex_MapRootLevel::clear_blocks() {
  blocks_.Clear();
}
inline const ::MapDataBlock& OsmAndMapIndex_MapRootLevel::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::MapDataBlock* OsmAndMapIndex_MapRootLevel::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::MapDataBlock* OsmAndMapIndex_MapRootLevel::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataBlock >&
OsmAndMapIndex_MapRootLevel::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataBlock >*
OsmAndMapIndex_MapRootLevel::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// OsmAndMapIndex_MapDataBox

// required sint32 left = 1;
inline bool OsmAndMapIndex_MapDataBox::has_left() const {
  return _has_bit(0);
}
inline void OsmAndMapIndex_MapDataBox::clear_left() {
  left_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapDataBox::left() const {
  return left_;
}
inline void OsmAndMapIndex_MapDataBox::set_left(::google::protobuf::int32 value) {
  _set_bit(0);
  left_ = value;
}

// required sint32 right = 2;
inline bool OsmAndMapIndex_MapDataBox::has_right() const {
  return _has_bit(1);
}
inline void OsmAndMapIndex_MapDataBox::clear_right() {
  right_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapDataBox::right() const {
  return right_;
}
inline void OsmAndMapIndex_MapDataBox::set_right(::google::protobuf::int32 value) {
  _set_bit(1);
  right_ = value;
}

// required sint32 top = 3;
inline bool OsmAndMapIndex_MapDataBox::has_top() const {
  return _has_bit(2);
}
inline void OsmAndMapIndex_MapDataBox::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapDataBox::top() const {
  return top_;
}
inline void OsmAndMapIndex_MapDataBox::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// required sint32 bottom = 4;
inline bool OsmAndMapIndex_MapDataBox::has_bottom() const {
  return _has_bit(3);
}
inline void OsmAndMapIndex_MapDataBox::clear_bottom() {
  bottom_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapDataBox::bottom() const {
  return bottom_;
}
inline void OsmAndMapIndex_MapDataBox::set_bottom(::google::protobuf::int32 value) {
  _set_bit(3);
  bottom_ = value;
}

// optional fixed32 shiftToMapData = 5;
inline bool OsmAndMapIndex_MapDataBox::has_shifttomapdata() const {
  return _has_bit(4);
}
inline void OsmAndMapIndex_MapDataBox::clear_shifttomapdata() {
  shifttomapdata_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 OsmAndMapIndex_MapDataBox::shifttomapdata() const {
  return shifttomapdata_;
}
inline void OsmAndMapIndex_MapDataBox::set_shifttomapdata(::google::protobuf::uint32 value) {
  _set_bit(4);
  shifttomapdata_ = value;
}

// optional bool ocean = 6;
inline bool OsmAndMapIndex_MapDataBox::has_ocean() const {
  return _has_bit(5);
}
inline void OsmAndMapIndex_MapDataBox::clear_ocean() {
  ocean_ = false;
  _clear_bit(5);
}
inline bool OsmAndMapIndex_MapDataBox::ocean() const {
  return ocean_;
}
inline void OsmAndMapIndex_MapDataBox::set_ocean(bool value) {
  _set_bit(5);
  ocean_ = value;
}

// repeated .OsmAndMapIndex.MapDataBox boxes = 7;
inline int OsmAndMapIndex_MapDataBox::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndMapIndex_MapDataBox::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAndMapIndex_MapDataBox& OsmAndMapIndex_MapDataBox::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAndMapIndex_MapDataBox* OsmAndMapIndex_MapDataBox::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAndMapIndex_MapDataBox* OsmAndMapIndex_MapDataBox::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox >&
OsmAndMapIndex_MapDataBox::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapDataBox >*
OsmAndMapIndex_MapDataBox::mutable_boxes() {
  return &boxes_;
}

// -------------------------------------------------------------------

// OsmAndMapIndex

// required string name = 2;
inline bool OsmAndMapIndex::has_name() const {
  return _has_bit(0);
}
inline void OsmAndMapIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndMapIndex::name() const {
  return *name_;
}
inline void OsmAndMapIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndMapIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndMapIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndMapIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated .OsmAndMapIndex.MapEncodingRule rules = 4;
inline int OsmAndMapIndex::rules_size() const {
  return rules_.size();
}
inline void OsmAndMapIndex::clear_rules() {
  rules_.Clear();
}
inline const ::OsmAndMapIndex_MapEncodingRule& OsmAndMapIndex::rules(int index) const {
  return rules_.Get(index);
}
inline ::OsmAndMapIndex_MapEncodingRule* OsmAndMapIndex::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::OsmAndMapIndex_MapEncodingRule* OsmAndMapIndex::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapEncodingRule >&
OsmAndMapIndex::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapEncodingRule >*
OsmAndMapIndex::mutable_rules() {
  return &rules_;
}

// repeated .OsmAndMapIndex.MapRootLevel levels = 5;
inline int OsmAndMapIndex::levels_size() const {
  return levels_.size();
}
inline void OsmAndMapIndex::clear_levels() {
  levels_.Clear();
}
inline const ::OsmAndMapIndex_MapRootLevel& OsmAndMapIndex::levels(int index) const {
  return levels_.Get(index);
}
inline ::OsmAndMapIndex_MapRootLevel* OsmAndMapIndex::mutable_levels(int index) {
  return levels_.Mutable(index);
}
inline ::OsmAndMapIndex_MapRootLevel* OsmAndMapIndex::add_levels() {
  return levels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapRootLevel >&
OsmAndMapIndex::levels() const {
  return levels_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndMapIndex_MapRootLevel >*
OsmAndMapIndex::mutable_levels() {
  return &levels_;
}

// -------------------------------------------------------------------

// MapDataBlock

// optional uint64 baseId = 10;
inline bool MapDataBlock::has_baseid() const {
  return _has_bit(0);
}
inline void MapDataBlock::clear_baseid() {
  baseid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 MapDataBlock::baseid() const {
  return baseid_;
}
inline void MapDataBlock::set_baseid(::google::protobuf::uint64 value) {
  _set_bit(0);
  baseid_ = value;
}

// repeated .MapData dataObjects = 12;
inline int MapDataBlock::dataobjects_size() const {
  return dataobjects_.size();
}
inline void MapDataBlock::clear_dataobjects() {
  dataobjects_.Clear();
}
inline const ::MapData& MapDataBlock::dataobjects(int index) const {
  return dataobjects_.Get(index);
}
inline ::MapData* MapDataBlock::mutable_dataobjects(int index) {
  return dataobjects_.Mutable(index);
}
inline ::MapData* MapDataBlock::add_dataobjects() {
  return dataobjects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapData >&
MapDataBlock::dataobjects() const {
  return dataobjects_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapData >*
MapDataBlock::mutable_dataobjects() {
  return &dataobjects_;
}

// optional .StringTable stringTable = 15;
inline bool MapDataBlock::has_stringtable() const {
  return _has_bit(2);
}
inline void MapDataBlock::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::StringTable::Clear();
  _clear_bit(2);
}
inline const ::StringTable& MapDataBlock::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::StringTable* MapDataBlock::mutable_stringtable() {
  _set_bit(2);
  if (stringtable_ == NULL) stringtable_ = new ::StringTable;
  return stringtable_;
}

// -------------------------------------------------------------------

// MapData

// optional bytes coordinates = 1;
inline bool MapData::has_coordinates() const {
  return _has_bit(0);
}
inline void MapData::clear_coordinates() {
  if (coordinates_ != &_default_coordinates_) {
    coordinates_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MapData::coordinates() const {
  return *coordinates_;
}
inline void MapData::set_coordinates(const ::std::string& value) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
}
inline void MapData::set_coordinates(const char* value) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
}
inline void MapData::set_coordinates(const void* value, size_t size) {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_coordinates() {
  _set_bit(0);
  if (coordinates_ == &_default_coordinates_) {
    coordinates_ = new ::std::string;
  }
  return coordinates_;
}

// optional bytes areaCoordinates = 2;
inline bool MapData::has_areacoordinates() const {
  return _has_bit(1);
}
inline void MapData::clear_areacoordinates() {
  if (areacoordinates_ != &_default_areacoordinates_) {
    areacoordinates_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MapData::areacoordinates() const {
  return *areacoordinates_;
}
inline void MapData::set_areacoordinates(const ::std::string& value) {
  _set_bit(1);
  if (areacoordinates_ == &_default_areacoordinates_) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(value);
}
inline void MapData::set_areacoordinates(const char* value) {
  _set_bit(1);
  if (areacoordinates_ == &_default_areacoordinates_) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(value);
}
inline void MapData::set_areacoordinates(const void* value, size_t size) {
  _set_bit(1);
  if (areacoordinates_ == &_default_areacoordinates_) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_areacoordinates() {
  _set_bit(1);
  if (areacoordinates_ == &_default_areacoordinates_) {
    areacoordinates_ = new ::std::string;
  }
  return areacoordinates_;
}

// repeated bytes polygonInnerCoordinates = 4;
inline int MapData::polygoninnercoordinates_size() const {
  return polygoninnercoordinates_.size();
}
inline void MapData::clear_polygoninnercoordinates() {
  polygoninnercoordinates_.Clear();
}
inline const ::std::string& MapData::polygoninnercoordinates(int index) const {
  return polygoninnercoordinates_.Get(index);
}
inline ::std::string* MapData::mutable_polygoninnercoordinates(int index) {
  return polygoninnercoordinates_.Mutable(index);
}
inline void MapData::set_polygoninnercoordinates(int index, const ::std::string& value) {
  polygoninnercoordinates_.Mutable(index)->assign(value);
}
inline void MapData::set_polygoninnercoordinates(int index, const char* value) {
  polygoninnercoordinates_.Mutable(index)->assign(value);
}
inline void MapData::set_polygoninnercoordinates(int index, const void* value, size_t size) {
  polygoninnercoordinates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::add_polygoninnercoordinates() {
  return polygoninnercoordinates_.Add();
}
inline void MapData::add_polygoninnercoordinates(const ::std::string& value) {
  polygoninnercoordinates_.Add()->assign(value);
}
inline void MapData::add_polygoninnercoordinates(const char* value) {
  polygoninnercoordinates_.Add()->assign(value);
}
inline void MapData::add_polygoninnercoordinates(const void* value, size_t size) {
  polygoninnercoordinates_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapData::polygoninnercoordinates() const {
  return polygoninnercoordinates_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapData::mutable_polygoninnercoordinates() {
  return &polygoninnercoordinates_;
}

// optional bytes additionalTypes = 6;
inline bool MapData::has_additionaltypes() const {
  return _has_bit(3);
}
inline void MapData::clear_additionaltypes() {
  if (additionaltypes_ != &_default_additionaltypes_) {
    additionaltypes_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& MapData::additionaltypes() const {
  return *additionaltypes_;
}
inline void MapData::set_additionaltypes(const ::std::string& value) {
  _set_bit(3);
  if (additionaltypes_ == &_default_additionaltypes_) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(value);
}
inline void MapData::set_additionaltypes(const char* value) {
  _set_bit(3);
  if (additionaltypes_ == &_default_additionaltypes_) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(value);
}
inline void MapData::set_additionaltypes(const void* value, size_t size) {
  _set_bit(3);
  if (additionaltypes_ == &_default_additionaltypes_) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_additionaltypes() {
  _set_bit(3);
  if (additionaltypes_ == &_default_additionaltypes_) {
    additionaltypes_ = new ::std::string;
  }
  return additionaltypes_;
}

// required bytes types = 7;
inline bool MapData::has_types() const {
  return _has_bit(4);
}
inline void MapData::clear_types() {
  if (types_ != &_default_types_) {
    types_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MapData::types() const {
  return *types_;
}
inline void MapData::set_types(const ::std::string& value) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void MapData::set_types(const char* value) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void MapData::set_types(const void* value, size_t size) {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  types_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_types() {
  _set_bit(4);
  if (types_ == &_default_types_) {
    types_ = new ::std::string;
  }
  return types_;
}

// optional bytes stringNames = 10;
inline bool MapData::has_stringnames() const {
  return _has_bit(5);
}
inline void MapData::clear_stringnames() {
  if (stringnames_ != &_default_stringnames_) {
    stringnames_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& MapData::stringnames() const {
  return *stringnames_;
}
inline void MapData::set_stringnames(const ::std::string& value) {
  _set_bit(5);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void MapData::set_stringnames(const char* value) {
  _set_bit(5);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void MapData::set_stringnames(const void* value, size_t size) {
  _set_bit(5);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_stringnames() {
  _set_bit(5);
  if (stringnames_ == &_default_stringnames_) {
    stringnames_ = new ::std::string;
  }
  return stringnames_;
}

// required sint64 id = 12;
inline bool MapData::has_id() const {
  return _has_bit(6);
}
inline void MapData::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::int64 MapData::id() const {
  return id_;
}
inline void MapData::set_id(::google::protobuf::int64 value) {
  _set_bit(6);
  id_ = value;
}

// optional bytes rasterBytes = 15;
inline bool MapData::has_rasterbytes() const {
  return _has_bit(7);
}
inline void MapData::clear_rasterbytes() {
  if (rasterbytes_ != &_default_rasterbytes_) {
    rasterbytes_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& MapData::rasterbytes() const {
  return *rasterbytes_;
}
inline void MapData::set_rasterbytes(const ::std::string& value) {
  _set_bit(7);
  if (rasterbytes_ == &_default_rasterbytes_) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(value);
}
inline void MapData::set_rasterbytes(const char* value) {
  _set_bit(7);
  if (rasterbytes_ == &_default_rasterbytes_) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(value);
}
inline void MapData::set_rasterbytes(const void* value, size_t size) {
  _set_bit(7);
  if (rasterbytes_ == &_default_rasterbytes_) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_rasterbytes() {
  _set_bit(7);
  if (rasterbytes_ == &_default_rasterbytes_) {
    rasterbytes_ = new ::std::string;
  }
  return rasterbytes_;
}

// -------------------------------------------------------------------

// OsmAndAddressIndex_CitiesIndex

// required uint32 type = 2;
inline bool OsmAndAddressIndex_CitiesIndex::has_type() const {
  return _has_bit(0);
}
inline void OsmAndAddressIndex_CitiesIndex::clear_type() {
  type_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndAddressIndex_CitiesIndex::type() const {
  return type_;
}
inline void OsmAndAddressIndex_CitiesIndex::set_type(::google::protobuf::uint32 value) {
  _set_bit(0);
  type_ = value;
}

// repeated .CityIndex cities = 5;
inline int OsmAndAddressIndex_CitiesIndex::cities_size() const {
  return cities_.size();
}
inline void OsmAndAddressIndex_CitiesIndex::clear_cities() {
  cities_.Clear();
}
inline const ::CityIndex& OsmAndAddressIndex_CitiesIndex::cities(int index) const {
  return cities_.Get(index);
}
inline ::CityIndex* OsmAndAddressIndex_CitiesIndex::mutable_cities(int index) {
  return cities_.Mutable(index);
}
inline ::CityIndex* OsmAndAddressIndex_CitiesIndex::add_cities() {
  return cities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CityIndex >&
OsmAndAddressIndex_CitiesIndex::cities() const {
  return cities_;
}
inline ::google::protobuf::RepeatedPtrField< ::CityIndex >*
OsmAndAddressIndex_CitiesIndex::mutable_cities() {
  return &cities_;
}

// repeated .CityBlockIndex blocks = 7;
inline int OsmAndAddressIndex_CitiesIndex::blocks_size() const {
  return blocks_.size();
}
inline void OsmAndAddressIndex_CitiesIndex::clear_blocks() {
  blocks_.Clear();
}
inline const ::CityBlockIndex& OsmAndAddressIndex_CitiesIndex::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::CityBlockIndex* OsmAndAddressIndex_CitiesIndex::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::CityBlockIndex* OsmAndAddressIndex_CitiesIndex::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CityBlockIndex >&
OsmAndAddressIndex_CitiesIndex::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::CityBlockIndex >*
OsmAndAddressIndex_CitiesIndex::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// OsmAndAddressIndex

// required string name = 1;
inline bool OsmAndAddressIndex::has_name() const {
  return _has_bit(0);
}
inline void OsmAndAddressIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndAddressIndex::name() const {
  return *name_;
}
inline void OsmAndAddressIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndAddressIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndAddressIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndAddressIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool OsmAndAddressIndex::has_name_en() const {
  return _has_bit(1);
}
inline void OsmAndAddressIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OsmAndAddressIndex::name_en() const {
  return *name_en_;
}
inline void OsmAndAddressIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void OsmAndAddressIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void OsmAndAddressIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndAddressIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional .OsmAndTileBox boundaries = 3;
inline bool OsmAndAddressIndex::has_boundaries() const {
  return _has_bit(2);
}
inline void OsmAndAddressIndex::clear_boundaries() {
  if (boundaries_ != NULL) boundaries_->::OsmAndTileBox::Clear();
  _clear_bit(2);
}
inline const ::OsmAndTileBox& OsmAndAddressIndex::boundaries() const {
  return boundaries_ != NULL ? *boundaries_ : *default_instance_->boundaries_;
}
inline ::OsmAndTileBox* OsmAndAddressIndex::mutable_boundaries() {
  _set_bit(2);
  if (boundaries_ == NULL) boundaries_ = new ::OsmAndTileBox;
  return boundaries_;
}

// repeated .OsmAndAddressIndex.CitiesIndex cities = 6;
inline int OsmAndAddressIndex::cities_size() const {
  return cities_.size();
}
inline void OsmAndAddressIndex::clear_cities() {
  cities_.Clear();
}
inline const ::OsmAndAddressIndex_CitiesIndex& OsmAndAddressIndex::cities(int index) const {
  return cities_.Get(index);
}
inline ::OsmAndAddressIndex_CitiesIndex* OsmAndAddressIndex::mutable_cities(int index) {
  return cities_.Mutable(index);
}
inline ::OsmAndAddressIndex_CitiesIndex* OsmAndAddressIndex::add_cities() {
  return cities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex_CitiesIndex >&
OsmAndAddressIndex::cities() const {
  return cities_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndAddressIndex_CitiesIndex >*
OsmAndAddressIndex::mutable_cities() {
  return &cities_;
}

// optional .OsmAndAddressNameIndexData nameIndex = 7;
inline bool OsmAndAddressIndex::has_nameindex() const {
  return _has_bit(4);
}
inline void OsmAndAddressIndex::clear_nameindex() {
  if (nameindex_ != NULL) nameindex_->::OsmAndAddressNameIndexData::Clear();
  _clear_bit(4);
}
inline const ::OsmAndAddressNameIndexData& OsmAndAddressIndex::nameindex() const {
  return nameindex_ != NULL ? *nameindex_ : *default_instance_->nameindex_;
}
inline ::OsmAndAddressNameIndexData* OsmAndAddressIndex::mutable_nameindex() {
  _set_bit(4);
  if (nameindex_ == NULL) nameindex_ = new ::OsmAndAddressNameIndexData;
  return nameindex_;
}

// -------------------------------------------------------------------

// OsmAndAddressNameIndexData_AddressNameIndexData

// repeated .AddressNameIndexDataAtom atom = 4;
inline int OsmAndAddressNameIndexData_AddressNameIndexData::atom_size() const {
  return atom_.size();
}
inline void OsmAndAddressNameIndexData_AddressNameIndexData::clear_atom() {
  atom_.Clear();
}
inline const ::AddressNameIndexDataAtom& OsmAndAddressNameIndexData_AddressNameIndexData::atom(int index) const {
  return atom_.Get(index);
}
inline ::AddressNameIndexDataAtom* OsmAndAddressNameIndexData_AddressNameIndexData::mutable_atom(int index) {
  return atom_.Mutable(index);
}
inline ::AddressNameIndexDataAtom* OsmAndAddressNameIndexData_AddressNameIndexData::add_atom() {
  return atom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom >&
OsmAndAddressNameIndexData_AddressNameIndexData::atom() const {
  return atom_;
}
inline ::google::protobuf::RepeatedPtrField< ::AddressNameIndexDataAtom >*
OsmAndAddressNameIndexData_AddressNameIndexData::mutable_atom() {
  return &atom_;
}

// -------------------------------------------------------------------

// OsmAndAddressNameIndexData

// required .IndexedStringTable table = 4;
inline bool OsmAndAddressNameIndexData::has_table() const {
  return _has_bit(0);
}
inline void OsmAndAddressNameIndexData::clear_table() {
  if (table_ != NULL) table_->::IndexedStringTable::Clear();
  _clear_bit(0);
}
inline const ::IndexedStringTable& OsmAndAddressNameIndexData::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::IndexedStringTable* OsmAndAddressNameIndexData::mutable_table() {
  _set_bit(0);
  if (table_ == NULL) table_ = new ::IndexedStringTable;
  return table_;
}

// repeated .OsmAndAddressNameIndexData.AddressNameIndexData atom = 7;
inline int OsmAndAddressNameIndexData::atom_size() const {
  return atom_.size();
}
inline void OsmAndAddressNameIndexData::clear_atom() {
  atom_.Clear();
}
inline const ::OsmAndAddressNameIndexData_AddressNameIndexData& OsmAndAddressNameIndexData::atom(int index) const {
  return atom_.Get(index);
}
inline ::OsmAndAddressNameIndexData_AddressNameIndexData* OsmAndAddressNameIndexData::mutable_atom(int index) {
  return atom_.Mutable(index);
}
inline ::OsmAndAddressNameIndexData_AddressNameIndexData* OsmAndAddressNameIndexData::add_atom() {
  return atom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndAddressNameIndexData_AddressNameIndexData >&
OsmAndAddressNameIndexData::atom() const {
  return atom_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndAddressNameIndexData_AddressNameIndexData >*
OsmAndAddressNameIndexData::mutable_atom() {
  return &atom_;
}

// -------------------------------------------------------------------

// AddressNameIndexDataAtom

// optional string name = 1;
inline bool AddressNameIndexDataAtom::has_name() const {
  return _has_bit(0);
}
inline void AddressNameIndexDataAtom::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AddressNameIndexDataAtom::name() const {
  return *name_;
}
inline void AddressNameIndexDataAtom::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddressNameIndexDataAtom::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddressNameIndexDataAtom::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressNameIndexDataAtom::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string nameEn = 2;
inline bool AddressNameIndexDataAtom::has_nameen() const {
  return _has_bit(1);
}
inline void AddressNameIndexDataAtom::clear_nameen() {
  if (nameen_ != &_default_nameen_) {
    nameen_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AddressNameIndexDataAtom::nameen() const {
  return *nameen_;
}
inline void AddressNameIndexDataAtom::set_nameen(const ::std::string& value) {
  _set_bit(1);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void AddressNameIndexDataAtom::set_nameen(const char* value) {
  _set_bit(1);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void AddressNameIndexDataAtom::set_nameen(const char* value, size_t size) {
  _set_bit(1);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressNameIndexDataAtom::mutable_nameen() {
  _set_bit(1);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  return nameen_;
}

// required uint32 type = 3;
inline bool AddressNameIndexDataAtom::has_type() const {
  return _has_bit(2);
}
inline void AddressNameIndexDataAtom::clear_type() {
  type_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 AddressNameIndexDataAtom::type() const {
  return type_;
}
inline void AddressNameIndexDataAtom::set_type(::google::protobuf::uint32 value) {
  _set_bit(2);
  type_ = value;
}

// repeated int32 shiftToIndex = 5;
inline int AddressNameIndexDataAtom::shifttoindex_size() const {
  return shifttoindex_.size();
}
inline void AddressNameIndexDataAtom::clear_shifttoindex() {
  shifttoindex_.Clear();
}
inline ::google::protobuf::int32 AddressNameIndexDataAtom::shifttoindex(int index) const {
  return shifttoindex_.Get(index);
}
inline void AddressNameIndexDataAtom::set_shifttoindex(int index, ::google::protobuf::int32 value) {
  shifttoindex_.Set(index, value);
}
inline void AddressNameIndexDataAtom::add_shifttoindex(::google::protobuf::int32 value) {
  shifttoindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AddressNameIndexDataAtom::shifttoindex() const {
  return shifttoindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AddressNameIndexDataAtom::mutable_shifttoindex() {
  return &shifttoindex_;
}

// repeated int32 shiftToCityIndex = 6;
inline int AddressNameIndexDataAtom::shifttocityindex_size() const {
  return shifttocityindex_.size();
}
inline void AddressNameIndexDataAtom::clear_shifttocityindex() {
  shifttocityindex_.Clear();
}
inline ::google::protobuf::int32 AddressNameIndexDataAtom::shifttocityindex(int index) const {
  return shifttocityindex_.Get(index);
}
inline void AddressNameIndexDataAtom::set_shifttocityindex(int index, ::google::protobuf::int32 value) {
  shifttocityindex_.Set(index, value);
}
inline void AddressNameIndexDataAtom::add_shifttocityindex(::google::protobuf::int32 value) {
  shifttocityindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AddressNameIndexDataAtom::shifttocityindex() const {
  return shifttocityindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AddressNameIndexDataAtom::mutable_shifttocityindex() {
  return &shifttocityindex_;
}

// -------------------------------------------------------------------

// CityIndex

// optional uint32 city_type = 1;
inline bool CityIndex::has_city_type() const {
  return _has_bit(0);
}
inline void CityIndex::clear_city_type() {
  city_type_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CityIndex::city_type() const {
  return city_type_;
}
inline void CityIndex::set_city_type(::google::protobuf::uint32 value) {
  _set_bit(0);
  city_type_ = value;
}

// required string name = 2;
inline bool CityIndex::has_name() const {
  return _has_bit(1);
}
inline void CityIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CityIndex::name() const {
  return *name_;
}
inline void CityIndex::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CityIndex::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CityIndex::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 3;
inline bool CityIndex::has_name_en() const {
  return _has_bit(2);
}
inline void CityIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CityIndex::name_en() const {
  return *name_en_;
}
inline void CityIndex::set_name_en(const ::std::string& value) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void CityIndex::set_name_en(const char* value) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void CityIndex::set_name_en(const char* value, size_t size) {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::mutable_name_en() {
  _set_bit(2);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional uint64 id = 4;
inline bool CityIndex::has_id() const {
  return _has_bit(3);
}
inline void CityIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 CityIndex::id() const {
  return id_;
}
inline void CityIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(3);
  id_ = value;
}

// required uint32 x = 5;
inline bool CityIndex::has_x() const {
  return _has_bit(4);
}
inline void CityIndex::clear_x() {
  x_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 CityIndex::x() const {
  return x_;
}
inline void CityIndex::set_x(::google::protobuf::uint32 value) {
  _set_bit(4);
  x_ = value;
}

// required uint32 y = 6;
inline bool CityIndex::has_y() const {
  return _has_bit(5);
}
inline void CityIndex::clear_y() {
  y_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 CityIndex::y() const {
  return y_;
}
inline void CityIndex::set_y(::google::protobuf::uint32 value) {
  _set_bit(5);
  y_ = value;
}

// optional fixed32 shiftToCityBlockIndex = 10;
inline bool CityIndex::has_shifttocityblockindex() const {
  return _has_bit(6);
}
inline void CityIndex::clear_shifttocityblockindex() {
  shifttocityblockindex_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 CityIndex::shifttocityblockindex() const {
  return shifttocityblockindex_;
}
inline void CityIndex::set_shifttocityblockindex(::google::protobuf::uint32 value) {
  _set_bit(6);
  shifttocityblockindex_ = value;
}

// -------------------------------------------------------------------

// CityBlockIndex

// optional fixed32 shiftToCityIndex = 4;
inline bool CityBlockIndex::has_shifttocityindex() const {
  return _has_bit(0);
}
inline void CityBlockIndex::clear_shifttocityindex() {
  shifttocityindex_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CityBlockIndex::shifttocityindex() const {
  return shifttocityindex_;
}
inline void CityBlockIndex::set_shifttocityindex(::google::protobuf::uint32 value) {
  _set_bit(0);
  shifttocityindex_ = value;
}

// repeated .BuildingIndex buildings = 10;
inline int CityBlockIndex::buildings_size() const {
  return buildings_.size();
}
inline void CityBlockIndex::clear_buildings() {
  buildings_.Clear();
}
inline const ::BuildingIndex& CityBlockIndex::buildings(int index) const {
  return buildings_.Get(index);
}
inline ::BuildingIndex* CityBlockIndex::mutable_buildings(int index) {
  return buildings_.Mutable(index);
}
inline ::BuildingIndex* CityBlockIndex::add_buildings() {
  return buildings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
CityBlockIndex::buildings() const {
  return buildings_;
}
inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
CityBlockIndex::mutable_buildings() {
  return &buildings_;
}

// repeated .StreetIndex streets = 12;
inline int CityBlockIndex::streets_size() const {
  return streets_.size();
}
inline void CityBlockIndex::clear_streets() {
  streets_.Clear();
}
inline const ::StreetIndex& CityBlockIndex::streets(int index) const {
  return streets_.Get(index);
}
inline ::StreetIndex* CityBlockIndex::mutable_streets(int index) {
  return streets_.Mutable(index);
}
inline ::StreetIndex* CityBlockIndex::add_streets() {
  return streets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StreetIndex >&
CityBlockIndex::streets() const {
  return streets_;
}
inline ::google::protobuf::RepeatedPtrField< ::StreetIndex >*
CityBlockIndex::mutable_streets() {
  return &streets_;
}

// -------------------------------------------------------------------

// StreetIndex

// required string name = 1;
inline bool StreetIndex::has_name() const {
  return _has_bit(0);
}
inline void StreetIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StreetIndex::name() const {
  return *name_;
}
inline void StreetIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool StreetIndex::has_name_en() const {
  return _has_bit(1);
}
inline void StreetIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StreetIndex::name_en() const {
  return *name_en_;
}
inline void StreetIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// required sint32 x = 3;
inline bool StreetIndex::has_x() const {
  return _has_bit(2);
}
inline void StreetIndex::clear_x() {
  x_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 StreetIndex::x() const {
  return x_;
}
inline void StreetIndex::set_x(::google::protobuf::int32 value) {
  _set_bit(2);
  x_ = value;
}

// required sint32 y = 4;
inline bool StreetIndex::has_y() const {
  return _has_bit(3);
}
inline void StreetIndex::clear_y() {
  y_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 StreetIndex::y() const {
  return y_;
}
inline void StreetIndex::set_y(::google::protobuf::int32 value) {
  _set_bit(3);
  y_ = value;
}

// optional uint64 id = 6;
inline bool StreetIndex::has_id() const {
  return _has_bit(4);
}
inline void StreetIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 StreetIndex::id() const {
  return id_;
}
inline void StreetIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(4);
  id_ = value;
}

// repeated .BuildingIndex buildings = 12;
inline int StreetIndex::buildings_size() const {
  return buildings_.size();
}
inline void StreetIndex::clear_buildings() {
  buildings_.Clear();
}
inline const ::BuildingIndex& StreetIndex::buildings(int index) const {
  return buildings_.Get(index);
}
inline ::BuildingIndex* StreetIndex::mutable_buildings(int index) {
  return buildings_.Mutable(index);
}
inline ::BuildingIndex* StreetIndex::add_buildings() {
  return buildings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BuildingIndex >&
StreetIndex::buildings() const {
  return buildings_;
}
inline ::google::protobuf::RepeatedPtrField< ::BuildingIndex >*
StreetIndex::mutable_buildings() {
  return &buildings_;
}

// repeated .StreetIntersection intersections = 5;
inline int StreetIndex::intersections_size() const {
  return intersections_.size();
}
inline void StreetIndex::clear_intersections() {
  intersections_.Clear();
}
inline const ::StreetIntersection& StreetIndex::intersections(int index) const {
  return intersections_.Get(index);
}
inline ::StreetIntersection* StreetIndex::mutable_intersections(int index) {
  return intersections_.Mutable(index);
}
inline ::StreetIntersection* StreetIndex::add_intersections() {
  return intersections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StreetIntersection >&
StreetIndex::intersections() const {
  return intersections_;
}
inline ::google::protobuf::RepeatedPtrField< ::StreetIntersection >*
StreetIndex::mutable_intersections() {
  return &intersections_;
}

// -------------------------------------------------------------------

// StreetIntersection

// required string name = 2;
inline bool StreetIntersection::has_name() const {
  return _has_bit(0);
}
inline void StreetIntersection::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StreetIntersection::name() const {
  return *name_;
}
inline void StreetIntersection::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIntersection::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIntersection::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIntersection::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 3;
inline bool StreetIntersection::has_name_en() const {
  return _has_bit(1);
}
inline void StreetIntersection::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StreetIntersection::name_en() const {
  return *name_en_;
}
inline void StreetIntersection::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIntersection::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIntersection::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIntersection::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// required sint32 intersectedX = 4;
inline bool StreetIntersection::has_intersectedx() const {
  return _has_bit(2);
}
inline void StreetIntersection::clear_intersectedx() {
  intersectedx_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 StreetIntersection::intersectedx() const {
  return intersectedx_;
}
inline void StreetIntersection::set_intersectedx(::google::protobuf::int32 value) {
  _set_bit(2);
  intersectedx_ = value;
}

// required sint32 intersectedY = 5;
inline bool StreetIntersection::has_intersectedy() const {
  return _has_bit(3);
}
inline void StreetIntersection::clear_intersectedy() {
  intersectedy_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 StreetIntersection::intersectedy() const {
  return intersectedy_;
}
inline void StreetIntersection::set_intersectedy(::google::protobuf::int32 value) {
  _set_bit(3);
  intersectedy_ = value;
}

// -------------------------------------------------------------------

// BuildingIndex

// required string name = 1;
inline bool BuildingIndex::has_name() const {
  return _has_bit(0);
}
inline void BuildingIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BuildingIndex::name() const {
  return *name_;
}
inline void BuildingIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BuildingIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BuildingIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string name_en = 2;
inline bool BuildingIndex::has_name_en() const {
  return _has_bit(1);
}
inline void BuildingIndex::clear_name_en() {
  if (name_en_ != &_default_name_en_) {
    name_en_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BuildingIndex::name_en() const {
  return *name_en_;
}
inline void BuildingIndex::set_name_en(const ::std::string& value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void BuildingIndex::set_name_en(const char* value) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void BuildingIndex::set_name_en(const char* value, size_t size) {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name_en() {
  _set_bit(1);
  if (name_en_ == &_default_name_en_) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}

// optional string name2 = 3;
inline bool BuildingIndex::has_name2() const {
  return _has_bit(2);
}
inline void BuildingIndex::clear_name2() {
  if (name2_ != &_default_name2_) {
    name2_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& BuildingIndex::name2() const {
  return *name2_;
}
inline void BuildingIndex::set_name2(const ::std::string& value) {
  _set_bit(2);
  if (name2_ == &_default_name2_) {
    name2_ = new ::std::string;
  }
  name2_->assign(value);
}
inline void BuildingIndex::set_name2(const char* value) {
  _set_bit(2);
  if (name2_ == &_default_name2_) {
    name2_ = new ::std::string;
  }
  name2_->assign(value);
}
inline void BuildingIndex::set_name2(const char* value, size_t size) {
  _set_bit(2);
  if (name2_ == &_default_name2_) {
    name2_ = new ::std::string;
  }
  name2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name2() {
  _set_bit(2);
  if (name2_ == &_default_name2_) {
    name2_ = new ::std::string;
  }
  return name2_;
}

// optional string name_en2 = 4;
inline bool BuildingIndex::has_name_en2() const {
  return _has_bit(3);
}
inline void BuildingIndex::clear_name_en2() {
  if (name_en2_ != &_default_name_en2_) {
    name_en2_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& BuildingIndex::name_en2() const {
  return *name_en2_;
}
inline void BuildingIndex::set_name_en2(const ::std::string& value) {
  _set_bit(3);
  if (name_en2_ == &_default_name_en2_) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(value);
}
inline void BuildingIndex::set_name_en2(const char* value) {
  _set_bit(3);
  if (name_en2_ == &_default_name_en2_) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(value);
}
inline void BuildingIndex::set_name_en2(const char* value, size_t size) {
  _set_bit(3);
  if (name_en2_ == &_default_name_en2_) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name_en2() {
  _set_bit(3);
  if (name_en2_ == &_default_name_en2_) {
    name_en2_ = new ::std::string;
  }
  return name_en2_;
}

// optional sint32 interpolation = 5;
inline bool BuildingIndex::has_interpolation() const {
  return _has_bit(4);
}
inline void BuildingIndex::clear_interpolation() {
  interpolation_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 BuildingIndex::interpolation() const {
  return interpolation_;
}
inline void BuildingIndex::set_interpolation(::google::protobuf::int32 value) {
  _set_bit(4);
  interpolation_ = value;
}

// required sint32 x = 7;
inline bool BuildingIndex::has_x() const {
  return _has_bit(5);
}
inline void BuildingIndex::clear_x() {
  x_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 BuildingIndex::x() const {
  return x_;
}
inline void BuildingIndex::set_x(::google::protobuf::int32 value) {
  _set_bit(5);
  x_ = value;
}

// required sint32 y = 8;
inline bool BuildingIndex::has_y() const {
  return _has_bit(6);
}
inline void BuildingIndex::clear_y() {
  y_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 BuildingIndex::y() const {
  return y_;
}
inline void BuildingIndex::set_y(::google::protobuf::int32 value) {
  _set_bit(6);
  y_ = value;
}

// optional sint32 x2 = 9;
inline bool BuildingIndex::has_x2() const {
  return _has_bit(7);
}
inline void BuildingIndex::clear_x2() {
  x2_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 BuildingIndex::x2() const {
  return x2_;
}
inline void BuildingIndex::set_x2(::google::protobuf::int32 value) {
  _set_bit(7);
  x2_ = value;
}

// optional sint32 y2 = 10;
inline bool BuildingIndex::has_y2() const {
  return _has_bit(8);
}
inline void BuildingIndex::clear_y2() {
  y2_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 BuildingIndex::y2() const {
  return y2_;
}
inline void BuildingIndex::set_y2(::google::protobuf::int32 value) {
  _set_bit(8);
  y2_ = value;
}

// optional uint64 id = 13;
inline bool BuildingIndex::has_id() const {
  return _has_bit(9);
}
inline void BuildingIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(9);
}
inline ::google::protobuf::uint64 BuildingIndex::id() const {
  return id_;
}
inline void BuildingIndex::set_id(::google::protobuf::uint64 value) {
  _set_bit(9);
  id_ = value;
}

// optional string postcode = 14;
inline bool BuildingIndex::has_postcode() const {
  return _has_bit(10);
}
inline void BuildingIndex::clear_postcode() {
  if (postcode_ != &_default_postcode_) {
    postcode_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& BuildingIndex::postcode() const {
  return *postcode_;
}
inline void BuildingIndex::set_postcode(const ::std::string& value) {
  _set_bit(10);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void BuildingIndex::set_postcode(const char* value) {
  _set_bit(10);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void BuildingIndex::set_postcode(const char* value, size_t size) {
  _set_bit(10);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_postcode() {
  _set_bit(10);
  if (postcode_ == &_default_postcode_) {
    postcode_ = new ::std::string;
  }
  return postcode_;
}

// -------------------------------------------------------------------

// TransportRoutes

// repeated .TransportRoute routes = 6;
inline int TransportRoutes::routes_size() const {
  return routes_.size();
}
inline void TransportRoutes::clear_routes() {
  routes_.Clear();
}
inline const ::TransportRoute& TransportRoutes::routes(int index) const {
  return routes_.Get(index);
}
inline ::TransportRoute* TransportRoutes::mutable_routes(int index) {
  return routes_.Mutable(index);
}
inline ::TransportRoute* TransportRoutes::add_routes() {
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRoute >&
TransportRoutes::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRoute >*
TransportRoutes::mutable_routes() {
  return &routes_;
}

// -------------------------------------------------------------------

// TransportRoute

// required uint64 id = 1;
inline bool TransportRoute::has_id() const {
  return _has_bit(0);
}
inline void TransportRoute::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 TransportRoute::id() const {
  return id_;
}
inline void TransportRoute::set_id(::google::protobuf::uint64 value) {
  _set_bit(0);
  id_ = value;
}

// optional uint32 type = 3;
inline bool TransportRoute::has_type() const {
  return _has_bit(1);
}
inline void TransportRoute::clear_type() {
  type_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 TransportRoute::type() const {
  return type_;
}
inline void TransportRoute::set_type(::google::protobuf::uint32 value) {
  _set_bit(1);
  type_ = value;
}

// optional uint32 operator = 4;
inline bool TransportRoute::has_operator_() const {
  return _has_bit(2);
}
inline void TransportRoute::clear_operator_() {
  operator__ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 TransportRoute::operator_() const {
  return operator__;
}
inline void TransportRoute::set_operator_(::google::protobuf::uint32 value) {
  _set_bit(2);
  operator__ = value;
}

// optional string ref = 5;
inline bool TransportRoute::has_ref() const {
  return _has_bit(3);
}
inline void TransportRoute::clear_ref() {
  if (ref_ != &_default_ref_) {
    ref_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& TransportRoute::ref() const {
  return *ref_;
}
inline void TransportRoute::set_ref(const ::std::string& value) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void TransportRoute::set_ref(const char* value) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void TransportRoute::set_ref(const char* value, size_t size) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRoute::mutable_ref() {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  return ref_;
}

// optional uint32 name = 6;
inline bool TransportRoute::has_name() const {
  return _has_bit(4);
}
inline void TransportRoute::clear_name() {
  name_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportRoute::name() const {
  return name_;
}
inline void TransportRoute::set_name(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportRoute::has_name_en() const {
  return _has_bit(5);
}
inline void TransportRoute::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 TransportRoute::name_en() const {
  return name_en_;
}
inline void TransportRoute::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(5);
  name_en_ = value;
}

// optional uint32 distance = 8;
inline bool TransportRoute::has_distance() const {
  return _has_bit(6);
}
inline void TransportRoute::clear_distance() {
  distance_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 TransportRoute::distance() const {
  return distance_;
}
inline void TransportRoute::set_distance(::google::protobuf::uint32 value) {
  _set_bit(6);
  distance_ = value;
}

// repeated .TransportRouteStop directStops = 15;
inline int TransportRoute::directstops_size() const {
  return directstops_.size();
}
inline void TransportRoute::clear_directstops() {
  directstops_.Clear();
}
inline const ::TransportRouteStop& TransportRoute::directstops(int index) const {
  return directstops_.Get(index);
}
inline ::TransportRouteStop* TransportRoute::mutable_directstops(int index) {
  return directstops_.Mutable(index);
}
inline ::TransportRouteStop* TransportRoute::add_directstops() {
  return directstops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
TransportRoute::directstops() const {
  return directstops_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
TransportRoute::mutable_directstops() {
  return &directstops_;
}

// repeated .TransportRouteStop reverseStops = 16;
inline int TransportRoute::reversestops_size() const {
  return reversestops_.size();
}
inline void TransportRoute::clear_reversestops() {
  reversestops_.Clear();
}
inline const ::TransportRouteStop& TransportRoute::reversestops(int index) const {
  return reversestops_.Get(index);
}
inline ::TransportRouteStop* TransportRoute::mutable_reversestops(int index) {
  return reversestops_.Mutable(index);
}
inline ::TransportRouteStop* TransportRoute::add_reversestops() {
  return reversestops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >&
TransportRoute::reversestops() const {
  return reversestops_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportRouteStop >*
TransportRoute::mutable_reversestops() {
  return &reversestops_;
}

// -------------------------------------------------------------------

// TransportRouteStop

// required sint64 id = 1;
inline bool TransportRouteStop::has_id() const {
  return _has_bit(0);
}
inline void TransportRouteStop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 TransportRouteStop::id() const {
  return id_;
}
inline void TransportRouteStop::set_id(::google::protobuf::int64 value) {
  _set_bit(0);
  id_ = value;
}

// required sint32 dx = 2;
inline bool TransportRouteStop::has_dx() const {
  return _has_bit(1);
}
inline void TransportRouteStop::clear_dx() {
  dx_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportRouteStop::dx() const {
  return dx_;
}
inline void TransportRouteStop::set_dx(::google::protobuf::int32 value) {
  _set_bit(1);
  dx_ = value;
}

// required sint32 dy = 3;
inline bool TransportRouteStop::has_dy() const {
  return _has_bit(2);
}
inline void TransportRouteStop::clear_dy() {
  dy_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 TransportRouteStop::dy() const {
  return dy_;
}
inline void TransportRouteStop::set_dy(::google::protobuf::int32 value) {
  _set_bit(2);
  dy_ = value;
}

// required uint32 name = 6;
inline bool TransportRouteStop::has_name() const {
  return _has_bit(3);
}
inline void TransportRouteStop::clear_name() {
  name_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 TransportRouteStop::name() const {
  return name_;
}
inline void TransportRouteStop::set_name(::google::protobuf::uint32 value) {
  _set_bit(3);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportRouteStop::has_name_en() const {
  return _has_bit(4);
}
inline void TransportRouteStop::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportRouteStop::name_en() const {
  return name_en_;
}
inline void TransportRouteStop::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_en_ = value;
}

// -------------------------------------------------------------------

// TransportStop

// required sint32 dx = 1;
inline bool TransportStop::has_dx() const {
  return _has_bit(0);
}
inline void TransportStop::clear_dx() {
  dx_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TransportStop::dx() const {
  return dx_;
}
inline void TransportStop::set_dx(::google::protobuf::int32 value) {
  _set_bit(0);
  dx_ = value;
}

// required sint32 dy = 2;
inline bool TransportStop::has_dy() const {
  return _has_bit(1);
}
inline void TransportStop::clear_dy() {
  dy_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportStop::dy() const {
  return dy_;
}
inline void TransportStop::set_dy(::google::protobuf::int32 value) {
  _set_bit(1);
  dy_ = value;
}

// required sint64 id = 5;
inline bool TransportStop::has_id() const {
  return _has_bit(2);
}
inline void TransportStop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 TransportStop::id() const {
  return id_;
}
inline void TransportStop::set_id(::google::protobuf::int64 value) {
  _set_bit(2);
  id_ = value;
}

// required uint32 name = 6;
inline bool TransportStop::has_name() const {
  return _has_bit(3);
}
inline void TransportStop::clear_name() {
  name_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 TransportStop::name() const {
  return name_;
}
inline void TransportStop::set_name(::google::protobuf::uint32 value) {
  _set_bit(3);
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportStop::has_name_en() const {
  return _has_bit(4);
}
inline void TransportStop::clear_name_en() {
  name_en_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 TransportStop::name_en() const {
  return name_en_;
}
inline void TransportStop::set_name_en(::google::protobuf::uint32 value) {
  _set_bit(4);
  name_en_ = value;
}

// repeated uint32 routes = 16;
inline int TransportStop::routes_size() const {
  return routes_.size();
}
inline void TransportStop::clear_routes() {
  routes_.Clear();
}
inline ::google::protobuf::uint32 TransportStop::routes(int index) const {
  return routes_.Get(index);
}
inline void TransportStop::set_routes(int index, ::google::protobuf::uint32 value) {
  routes_.Set(index, value);
}
inline void TransportStop::add_routes(::google::protobuf::uint32 value) {
  routes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportStop::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportStop::mutable_routes() {
  return &routes_;
}

// -------------------------------------------------------------------

// TransportStopsTree

// required sint32 left = 1;
inline bool TransportStopsTree::has_left() const {
  return _has_bit(0);
}
inline void TransportStopsTree::clear_left() {
  left_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TransportStopsTree::left() const {
  return left_;
}
inline void TransportStopsTree::set_left(::google::protobuf::int32 value) {
  _set_bit(0);
  left_ = value;
}

// required sint32 right = 2;
inline bool TransportStopsTree::has_right() const {
  return _has_bit(1);
}
inline void TransportStopsTree::clear_right() {
  right_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TransportStopsTree::right() const {
  return right_;
}
inline void TransportStopsTree::set_right(::google::protobuf::int32 value) {
  _set_bit(1);
  right_ = value;
}

// required sint32 top = 3;
inline bool TransportStopsTree::has_top() const {
  return _has_bit(2);
}
inline void TransportStopsTree::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 TransportStopsTree::top() const {
  return top_;
}
inline void TransportStopsTree::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// required sint32 bottom = 4;
inline bool TransportStopsTree::has_bottom() const {
  return _has_bit(3);
}
inline void TransportStopsTree::clear_bottom() {
  bottom_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 TransportStopsTree::bottom() const {
  return bottom_;
}
inline void TransportStopsTree::set_bottom(::google::protobuf::int32 value) {
  _set_bit(3);
  bottom_ = value;
}

// repeated .TransportStopsTree subtrees = 7;
inline int TransportStopsTree::subtrees_size() const {
  return subtrees_.size();
}
inline void TransportStopsTree::clear_subtrees() {
  subtrees_.Clear();
}
inline const ::TransportStopsTree& TransportStopsTree::subtrees(int index) const {
  return subtrees_.Get(index);
}
inline ::TransportStopsTree* TransportStopsTree::mutable_subtrees(int index) {
  return subtrees_.Mutable(index);
}
inline ::TransportStopsTree* TransportStopsTree::add_subtrees() {
  return subtrees_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >&
TransportStopsTree::subtrees() const {
  return subtrees_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportStopsTree >*
TransportStopsTree::mutable_subtrees() {
  return &subtrees_;
}

// repeated .TransportStop leafs = 8;
inline int TransportStopsTree::leafs_size() const {
  return leafs_.size();
}
inline void TransportStopsTree::clear_leafs() {
  leafs_.Clear();
}
inline const ::TransportStop& TransportStopsTree::leafs(int index) const {
  return leafs_.Get(index);
}
inline ::TransportStop* TransportStopsTree::mutable_leafs(int index) {
  return leafs_.Mutable(index);
}
inline ::TransportStop* TransportStopsTree::add_leafs() {
  return leafs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransportStop >&
TransportStopsTree::leafs() const {
  return leafs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransportStop >*
TransportStopsTree::mutable_leafs() {
  return &leafs_;
}

// optional uint64 baseId = 16;
inline bool TransportStopsTree::has_baseid() const {
  return _has_bit(6);
}
inline void TransportStopsTree::clear_baseid() {
  baseid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::uint64 TransportStopsTree::baseid() const {
  return baseid_;
}
inline void TransportStopsTree::set_baseid(::google::protobuf::uint64 value) {
  _set_bit(6);
  baseid_ = value;
}

// -------------------------------------------------------------------

// OsmAndTransportIndex

// optional string name = 1;
inline bool OsmAndTransportIndex::has_name() const {
  return _has_bit(0);
}
inline void OsmAndTransportIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndTransportIndex::name() const {
  return *name_;
}
inline void OsmAndTransportIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndTransportIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndTransportIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndTransportIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional .TransportRoutes routes = 3;
inline bool OsmAndTransportIndex::has_routes() const {
  return _has_bit(1);
}
inline void OsmAndTransportIndex::clear_routes() {
  if (routes_ != NULL) routes_->::TransportRoutes::Clear();
  _clear_bit(1);
}
inline const ::TransportRoutes& OsmAndTransportIndex::routes() const {
  return routes_ != NULL ? *routes_ : *default_instance_->routes_;
}
inline ::TransportRoutes* OsmAndTransportIndex::mutable_routes() {
  _set_bit(1);
  if (routes_ == NULL) routes_ = new ::TransportRoutes;
  return routes_;
}

// optional .TransportStopsTree stops = 6;
inline bool OsmAndTransportIndex::has_stops() const {
  return _has_bit(2);
}
inline void OsmAndTransportIndex::clear_stops() {
  if (stops_ != NULL) stops_->::TransportStopsTree::Clear();
  _clear_bit(2);
}
inline const ::TransportStopsTree& OsmAndTransportIndex::stops() const {
  return stops_ != NULL ? *stops_ : *default_instance_->stops_;
}
inline ::TransportStopsTree* OsmAndTransportIndex::mutable_stops() {
  _set_bit(2);
  if (stops_ == NULL) stops_ = new ::TransportStopsTree;
  return stops_;
}

// required .StringTable stringTable = 9;
inline bool OsmAndTransportIndex::has_stringtable() const {
  return _has_bit(3);
}
inline void OsmAndTransportIndex::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::StringTable::Clear();
  _clear_bit(3);
}
inline const ::StringTable& OsmAndTransportIndex::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::StringTable* OsmAndTransportIndex::mutable_stringtable() {
  _set_bit(3);
  if (stringtable_ == NULL) stringtable_ = new ::StringTable;
  return stringtable_;
}

// -------------------------------------------------------------------

// OsmAndPoiIndex

// required string name = 1;
inline bool OsmAndPoiIndex::has_name() const {
  return _has_bit(0);
}
inline void OsmAndPoiIndex::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndPoiIndex::name() const {
  return *name_;
}
inline void OsmAndPoiIndex::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiIndex::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiIndex::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiIndex::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .OsmAndTileBox boundaries = 2;
inline bool OsmAndPoiIndex::has_boundaries() const {
  return _has_bit(1);
}
inline void OsmAndPoiIndex::clear_boundaries() {
  if (boundaries_ != NULL) boundaries_->::OsmAndTileBox::Clear();
  _clear_bit(1);
}
inline const ::OsmAndTileBox& OsmAndPoiIndex::boundaries() const {
  return boundaries_ != NULL ? *boundaries_ : *default_instance_->boundaries_;
}
inline ::OsmAndTileBox* OsmAndPoiIndex::mutable_boundaries() {
  _set_bit(1);
  if (boundaries_ == NULL) boundaries_ = new ::OsmAndTileBox;
  return boundaries_;
}

// repeated .OsmAndCategoryTable categoriesTable = 3;
inline int OsmAndPoiIndex::categoriestable_size() const {
  return categoriestable_.size();
}
inline void OsmAndPoiIndex::clear_categoriestable() {
  categoriestable_.Clear();
}
inline const ::OsmAndCategoryTable& OsmAndPoiIndex::categoriestable(int index) const {
  return categoriestable_.Get(index);
}
inline ::OsmAndCategoryTable* OsmAndPoiIndex::mutable_categoriestable(int index) {
  return categoriestable_.Mutable(index);
}
inline ::OsmAndCategoryTable* OsmAndPoiIndex::add_categoriestable() {
  return categoriestable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable >&
OsmAndPoiIndex::categoriestable() const {
  return categoriestable_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndCategoryTable >*
OsmAndPoiIndex::mutable_categoriestable() {
  return &categoriestable_;
}

// optional .OsmAndPoiNameIndex nameIndex = 4;
inline bool OsmAndPoiIndex::has_nameindex() const {
  return _has_bit(3);
}
inline void OsmAndPoiIndex::clear_nameindex() {
  if (nameindex_ != NULL) nameindex_->::OsmAndPoiNameIndex::Clear();
  _clear_bit(3);
}
inline const ::OsmAndPoiNameIndex& OsmAndPoiIndex::nameindex() const {
  return nameindex_ != NULL ? *nameindex_ : *default_instance_->nameindex_;
}
inline ::OsmAndPoiNameIndex* OsmAndPoiIndex::mutable_nameindex() {
  _set_bit(3);
  if (nameindex_ == NULL) nameindex_ = new ::OsmAndPoiNameIndex;
  return nameindex_;
}

// repeated .OsmAndPoiBox boxes = 6;
inline int OsmAndPoiIndex::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndPoiIndex::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAndPoiBox& OsmAndPoiIndex::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAndPoiBox* OsmAndPoiIndex::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAndPoiBox* OsmAndPoiIndex::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >&
OsmAndPoiIndex::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >*
OsmAndPoiIndex::mutable_boxes() {
  return &boxes_;
}

// repeated .OsmAndPoiBoxData poiData = 9;
inline int OsmAndPoiIndex::poidata_size() const {
  return poidata_.size();
}
inline void OsmAndPoiIndex::clear_poidata() {
  poidata_.Clear();
}
inline const ::OsmAndPoiBoxData& OsmAndPoiIndex::poidata(int index) const {
  return poidata_.Get(index);
}
inline ::OsmAndPoiBoxData* OsmAndPoiIndex::mutable_poidata(int index) {
  return poidata_.Mutable(index);
}
inline ::OsmAndPoiBoxData* OsmAndPoiIndex::add_poidata() {
  return poidata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData >&
OsmAndPoiIndex::poidata() const {
  return poidata_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxData >*
OsmAndPoiIndex::mutable_poidata() {
  return &poidata_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndex_OsmAndPoiNameIndexData

// repeated .OsmAndPoiNameIndexDataAtom atoms = 3;
inline int OsmAndPoiNameIndex_OsmAndPoiNameIndexData::atoms_size() const {
  return atoms_.size();
}
inline void OsmAndPoiNameIndex_OsmAndPoiNameIndexData::clear_atoms() {
  atoms_.Clear();
}
inline const ::OsmAndPoiNameIndexDataAtom& OsmAndPoiNameIndex_OsmAndPoiNameIndexData::atoms(int index) const {
  return atoms_.Get(index);
}
inline ::OsmAndPoiNameIndexDataAtom* OsmAndPoiNameIndex_OsmAndPoiNameIndexData::mutable_atoms(int index) {
  return atoms_.Mutable(index);
}
inline ::OsmAndPoiNameIndexDataAtom* OsmAndPoiNameIndex_OsmAndPoiNameIndexData::add_atoms() {
  return atoms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom >&
OsmAndPoiNameIndex_OsmAndPoiNameIndexData::atoms() const {
  return atoms_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndexDataAtom >*
OsmAndPoiNameIndex_OsmAndPoiNameIndexData::mutable_atoms() {
  return &atoms_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndex

// required .IndexedStringTable table = 3;
inline bool OsmAndPoiNameIndex::has_table() const {
  return _has_bit(0);
}
inline void OsmAndPoiNameIndex::clear_table() {
  if (table_ != NULL) table_->::IndexedStringTable::Clear();
  _clear_bit(0);
}
inline const ::IndexedStringTable& OsmAndPoiNameIndex::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::IndexedStringTable* OsmAndPoiNameIndex::mutable_table() {
  _set_bit(0);
  if (table_ == NULL) table_ = new ::IndexedStringTable;
  return table_;
}

// repeated .OsmAndPoiNameIndex.OsmAndPoiNameIndexData data = 5;
inline int OsmAndPoiNameIndex::data_size() const {
  return data_.size();
}
inline void OsmAndPoiNameIndex::clear_data() {
  data_.Clear();
}
inline const ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData& OsmAndPoiNameIndex::data(int index) const {
  return data_.Get(index);
}
inline ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData* OsmAndPoiNameIndex::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData* OsmAndPoiNameIndex::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData >&
OsmAndPoiNameIndex::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiNameIndex_OsmAndPoiNameIndexData >*
OsmAndPoiNameIndex::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndexDataAtom

// optional uint32 zoom = 2;
inline bool OsmAndPoiNameIndexDataAtom::has_zoom() const {
  return _has_bit(0);
}
inline void OsmAndPoiNameIndexDataAtom::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::zoom() const {
  return zoom_;
}
inline void OsmAndPoiNameIndexDataAtom::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// optional uint32 x = 3;
inline bool OsmAndPoiNameIndexDataAtom::has_x() const {
  return _has_bit(1);
}
inline void OsmAndPoiNameIndexDataAtom::clear_x() {
  x_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::x() const {
  return x_;
}
inline void OsmAndPoiNameIndexDataAtom::set_x(::google::protobuf::uint32 value) {
  _set_bit(1);
  x_ = value;
}

// optional uint32 y = 4;
inline bool OsmAndPoiNameIndexDataAtom::has_y() const {
  return _has_bit(2);
}
inline void OsmAndPoiNameIndexDataAtom::clear_y() {
  y_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::y() const {
  return y_;
}
inline void OsmAndPoiNameIndexDataAtom::set_y(::google::protobuf::uint32 value) {
  _set_bit(2);
  y_ = value;
}

// optional fixed32 shiftTo = 14;
inline bool OsmAndPoiNameIndexDataAtom::has_shiftto() const {
  return _has_bit(3);
}
inline void OsmAndPoiNameIndexDataAtom::clear_shiftto() {
  shiftto_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::shiftto() const {
  return shiftto_;
}
inline void OsmAndPoiNameIndexDataAtom::set_shiftto(::google::protobuf::uint32 value) {
  _set_bit(3);
  shiftto_ = value;
}

// -------------------------------------------------------------------

// OsmAndCategoryTable

// required string category = 1;
inline bool OsmAndCategoryTable::has_category() const {
  return _has_bit(0);
}
inline void OsmAndCategoryTable::clear_category() {
  if (category_ != &_default_category_) {
    category_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OsmAndCategoryTable::category() const {
  return *category_;
}
inline void OsmAndCategoryTable::set_category(const ::std::string& value) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void OsmAndCategoryTable::set_category(const char* value) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void OsmAndCategoryTable::set_category(const char* value, size_t size) {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndCategoryTable::mutable_category() {
  _set_bit(0);
  if (category_ == &_default_category_) {
    category_ = new ::std::string;
  }
  return category_;
}

// repeated string subcategories = 3;
inline int OsmAndCategoryTable::subcategories_size() const {
  return subcategories_.size();
}
inline void OsmAndCategoryTable::clear_subcategories() {
  subcategories_.Clear();
}
inline const ::std::string& OsmAndCategoryTable::subcategories(int index) const {
  return subcategories_.Get(index);
}
inline ::std::string* OsmAndCategoryTable::mutable_subcategories(int index) {
  return subcategories_.Mutable(index);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const ::std::string& value) {
  subcategories_.Mutable(index)->assign(value);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const char* value) {
  subcategories_.Mutable(index)->assign(value);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const char* value, size_t size) {
  subcategories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndCategoryTable::add_subcategories() {
  return subcategories_.Add();
}
inline void OsmAndCategoryTable::add_subcategories(const ::std::string& value) {
  subcategories_.Add()->assign(value);
}
inline void OsmAndCategoryTable::add_subcategories(const char* value) {
  subcategories_.Add()->assign(value);
}
inline void OsmAndCategoryTable::add_subcategories(const char* value, size_t size) {
  subcategories_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OsmAndCategoryTable::subcategories() const {
  return subcategories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OsmAndCategoryTable::mutable_subcategories() {
  return &subcategories_;
}

// -------------------------------------------------------------------

// OsmAndPoiBox

// required uint32 zoom = 1;
inline bool OsmAndPoiBox::has_zoom() const {
  return _has_bit(0);
}
inline void OsmAndPoiBox::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndPoiBox::zoom() const {
  return zoom_;
}
inline void OsmAndPoiBox::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// required sint32 left = 2;
inline bool OsmAndPoiBox::has_left() const {
  return _has_bit(1);
}
inline void OsmAndPoiBox::clear_left() {
  left_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 OsmAndPoiBox::left() const {
  return left_;
}
inline void OsmAndPoiBox::set_left(::google::protobuf::int32 value) {
  _set_bit(1);
  left_ = value;
}

// required sint32 top = 3;
inline bool OsmAndPoiBox::has_top() const {
  return _has_bit(2);
}
inline void OsmAndPoiBox::clear_top() {
  top_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 OsmAndPoiBox::top() const {
  return top_;
}
inline void OsmAndPoiBox::set_top(::google::protobuf::int32 value) {
  _set_bit(2);
  top_ = value;
}

// optional .OsmAndPoiCategories categories = 4;
inline bool OsmAndPoiBox::has_categories() const {
  return _has_bit(3);
}
inline void OsmAndPoiBox::clear_categories() {
  if (categories_ != NULL) categories_->::OsmAndPoiCategories::Clear();
  _clear_bit(3);
}
inline const ::OsmAndPoiCategories& OsmAndPoiBox::categories() const {
  return categories_ != NULL ? *categories_ : *default_instance_->categories_;
}
inline ::OsmAndPoiCategories* OsmAndPoiBox::mutable_categories() {
  _set_bit(3);
  if (categories_ == NULL) categories_ = new ::OsmAndPoiCategories;
  return categories_;
}

// repeated .OsmAndPoiBox subBoxes = 10;
inline int OsmAndPoiBox::subboxes_size() const {
  return subboxes_.size();
}
inline void OsmAndPoiBox::clear_subboxes() {
  subboxes_.Clear();
}
inline const ::OsmAndPoiBox& OsmAndPoiBox::subboxes(int index) const {
  return subboxes_.Get(index);
}
inline ::OsmAndPoiBox* OsmAndPoiBox::mutable_subboxes(int index) {
  return subboxes_.Mutable(index);
}
inline ::OsmAndPoiBox* OsmAndPoiBox::add_subboxes() {
  return subboxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >&
OsmAndPoiBox::subboxes() const {
  return subboxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBox >*
OsmAndPoiBox::mutable_subboxes() {
  return &subboxes_;
}

// optional fixed32 shiftToData = 14;
inline bool OsmAndPoiBox::has_shifttodata() const {
  return _has_bit(5);
}
inline void OsmAndPoiBox::clear_shifttodata() {
  shifttodata_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 OsmAndPoiBox::shifttodata() const {
  return shifttodata_;
}
inline void OsmAndPoiBox::set_shifttodata(::google::protobuf::uint32 value) {
  _set_bit(5);
  shifttodata_ = value;
}

// -------------------------------------------------------------------

// OsmAndPoiCategories

// repeated uint32 categories = 3;
inline int OsmAndPoiCategories::categories_size() const {
  return categories_.size();
}
inline void OsmAndPoiCategories::clear_categories() {
  categories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiCategories::categories(int index) const {
  return categories_.Get(index);
}
inline void OsmAndPoiCategories::set_categories(int index, ::google::protobuf::uint32 value) {
  categories_.Set(index, value);
}
inline void OsmAndPoiCategories::add_categories(::google::protobuf::uint32 value) {
  categories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiCategories::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiCategories::mutable_categories() {
  return &categories_;
}

// -------------------------------------------------------------------

// OsmAndPoiBoxData

// optional uint32 zoom = 1;
inline bool OsmAndPoiBoxData::has_zoom() const {
  return _has_bit(0);
}
inline void OsmAndPoiBoxData::clear_zoom() {
  zoom_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::zoom() const {
  return zoom_;
}
inline void OsmAndPoiBoxData::set_zoom(::google::protobuf::uint32 value) {
  _set_bit(0);
  zoom_ = value;
}

// optional uint32 x = 2;
inline bool OsmAndPoiBoxData::has_x() const {
  return _has_bit(1);
}
inline void OsmAndPoiBoxData::clear_x() {
  x_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::x() const {
  return x_;
}
inline void OsmAndPoiBoxData::set_x(::google::protobuf::uint32 value) {
  _set_bit(1);
  x_ = value;
}

// optional uint32 y = 3;
inline bool OsmAndPoiBoxData::has_y() const {
  return _has_bit(2);
}
inline void OsmAndPoiBoxData::clear_y() {
  y_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::y() const {
  return y_;
}
inline void OsmAndPoiBoxData::set_y(::google::protobuf::uint32 value) {
  _set_bit(2);
  y_ = value;
}

// repeated .OsmAndPoiBoxDataAtom poiData = 5;
inline int OsmAndPoiBoxData::poidata_size() const {
  return poidata_.size();
}
inline void OsmAndPoiBoxData::clear_poidata() {
  poidata_.Clear();
}
inline const ::OsmAndPoiBoxDataAtom& OsmAndPoiBoxData::poidata(int index) const {
  return poidata_.Get(index);
}
inline ::OsmAndPoiBoxDataAtom* OsmAndPoiBoxData::mutable_poidata(int index) {
  return poidata_.Mutable(index);
}
inline ::OsmAndPoiBoxDataAtom* OsmAndPoiBoxData::add_poidata() {
  return poidata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom >&
OsmAndPoiBoxData::poidata() const {
  return poidata_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAndPoiBoxDataAtom >*
OsmAndPoiBoxData::mutable_poidata() {
  return &poidata_;
}

// -------------------------------------------------------------------

// OsmAndPoiBoxDataAtom

// required sint32 dx = 2;
inline bool OsmAndPoiBoxDataAtom::has_dx() const {
  return _has_bit(0);
}
inline void OsmAndPoiBoxDataAtom::clear_dx() {
  dx_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 OsmAndPoiBoxDataAtom::dx() const {
  return dx_;
}
inline void OsmAndPoiBoxDataAtom::set_dx(::google::protobuf::int32 value) {
  _set_bit(0);
  dx_ = value;
}

// required sint32 dy = 3;
inline bool OsmAndPoiBoxDataAtom::has_dy() const {
  return _has_bit(1);
}
inline void OsmAndPoiBoxDataAtom::clear_dy() {
  dy_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 OsmAndPoiBoxDataAtom::dy() const {
  return dy_;
}
inline void OsmAndPoiBoxDataAtom::set_dy(::google::protobuf::int32 value) {
  _set_bit(1);
  dy_ = value;
}

// repeated uint32 categories = 4;
inline int OsmAndPoiBoxDataAtom::categories_size() const {
  return categories_.size();
}
inline void OsmAndPoiBoxDataAtom::clear_categories() {
  categories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxDataAtom::categories(int index) const {
  return categories_.Get(index);
}
inline void OsmAndPoiBoxDataAtom::set_categories(int index, ::google::protobuf::uint32 value) {
  categories_.Set(index, value);
}
inline void OsmAndPoiBoxDataAtom::add_categories(::google::protobuf::uint32 value) {
  categories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiBoxDataAtom::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiBoxDataAtom::mutable_categories() {
  return &categories_;
}

// optional string name = 6;
inline bool OsmAndPoiBoxDataAtom::has_name() const {
  return _has_bit(3);
}
inline void OsmAndPoiBoxDataAtom::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::name() const {
  return *name_;
}
inline void OsmAndPoiBoxDataAtom::set_name(const ::std::string& value) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_name(const char* value) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_name(const char* value, size_t size) {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_name() {
  _set_bit(3);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string nameEn = 7;
inline bool OsmAndPoiBoxDataAtom::has_nameen() const {
  return _has_bit(4);
}
inline void OsmAndPoiBoxDataAtom::clear_nameen() {
  if (nameen_ != &_default_nameen_) {
    nameen_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::nameen() const {
  return *nameen_;
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const ::std::string& value) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const char* value) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const char* value, size_t size) {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_nameen() {
  _set_bit(4);
  if (nameen_ == &_default_nameen_) {
    nameen_ = new ::std::string;
  }
  return nameen_;
}

// optional uint64 id = 8;
inline bool OsmAndPoiBoxDataAtom::has_id() const {
  return _has_bit(5);
}
inline void OsmAndPoiBoxDataAtom::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 OsmAndPoiBoxDataAtom::id() const {
  return id_;
}
inline void OsmAndPoiBoxDataAtom::set_id(::google::protobuf::uint64 value) {
  _set_bit(5);
  id_ = value;
}

// optional string openingHours = 10;
inline bool OsmAndPoiBoxDataAtom::has_openinghours() const {
  return _has_bit(6);
}
inline void OsmAndPoiBoxDataAtom::clear_openinghours() {
  if (openinghours_ != &_default_openinghours_) {
    openinghours_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::openinghours() const {
  return *openinghours_;
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const ::std::string& value) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const char* value) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const char* value, size_t size) {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_openinghours() {
  _set_bit(6);
  if (openinghours_ == &_default_openinghours_) {
    openinghours_ = new ::std::string;
  }
  return openinghours_;
}

// optional string site = 11;
inline bool OsmAndPoiBoxDataAtom::has_site() const {
  return _has_bit(7);
}
inline void OsmAndPoiBoxDataAtom::clear_site() {
  if (site_ != &_default_site_) {
    site_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::site() const {
  return *site_;
}
inline void OsmAndPoiBoxDataAtom::set_site(const ::std::string& value) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_site(const char* value) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_site(const char* value, size_t size) {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  site_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_site() {
  _set_bit(7);
  if (site_ == &_default_site_) {
    site_ = new ::std::string;
  }
  return site_;
}

// optional string phone = 12;
inline bool OsmAndPoiBoxDataAtom::has_phone() const {
  return _has_bit(8);
}
inline void OsmAndPoiBoxDataAtom::clear_phone() {
  if (phone_ != &_default_phone_) {
    phone_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::phone() const {
  return *phone_;
}
inline void OsmAndPoiBoxDataAtom::set_phone(const ::std::string& value) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_phone(const char* value) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_phone(const char* value, size_t size) {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_phone() {
  _set_bit(8);
  if (phone_ == &_default_phone_) {
    phone_ = new ::std::string;
  }
  return phone_;
}

// optional string note = 13;
inline bool OsmAndPoiBoxDataAtom::has_note() const {
  return _has_bit(9);
}
inline void OsmAndPoiBoxDataAtom::clear_note() {
  if (note_ != &_default_note_) {
    note_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& OsmAndPoiBoxDataAtom::note() const {
  return *note_;
}
inline void OsmAndPoiBoxDataAtom::set_note(const ::std::string& value) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_note(const char* value) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_note(const char* value, size_t size) {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  note_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_note() {
  _set_bit(9);
  if (note_ == &_default_note_) {
    note_ = new ::std::string;
  }
  return note_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_src_2fosmand_5fodb_2eproto__INCLUDED
